---
layout: post
title: 秒杀与超卖问题深度解析
categories: [System Design, Java]
---

# 秒杀与超卖问题深度解析

秒杀系统的核心挑战在于**瞬时高并发读写**与**数据一致性**之间的矛盾。在有限的库存下，如何保证不超卖、不丢失数据，同时维持系统的高可用与高性能，是系统设计的关键。

## 1. 核心问题：为什么会超卖？

超卖的本质是**并发环境下的竞态条件 (Race Condition)**。
传统扣减库存逻辑通常分为两步：
1. 查询库存：`SELECT stock FROM goods WHERE id = 1`
2. 扣减库存：`UPDATE goods SET stock = stock - 1 WHERE id = 1`

当多个线程并发执行步骤1时，都读到了有库存（如 stock=1），然后分别执行步骤2，导致库存扣减成负数。

---

## 2. 数据库层解决方案

对于中小体量的并发，可以直接利用数据库特性解决。

### ❌ 悲观锁 (Pessimistic Locking)
利用数据库的 `SELECT ... FOR UPDATE`。
```sql
SELECT quantity FROM items WHERE id = 1 FOR UPDATE;
UPDATE items SET quantity = quantity - 1 WHERE id = 1;
```
*   **评价**：**极不推荐**。行级锁会导致严重的锁竞争和等待，大量请求阻塞，拖垮数据库连接池，甚至引发死锁。

### ✅ 乐观锁 / Where 条件控制 (Optimistic Locking)
通过 SQL 的原子性与判断条件来保证。不显式加锁，而是利用 Update 的原子性和行锁。

**方案 A：版本号机制**
```sql
UPDATE items SET quantity = quantity - 1, version = version + 1 
WHERE id = 1 AND version = old_version;
```

**方案 B：库存兜底 (推荐)**
更精简的做法是直接在 Update 语句中判断库存。
```sql
UPDATE items SET quantity = quantity - 1 
WHERE id = 1 AND quantity > 0;
```
*   **评价**：利用数据库自身的行锁机制串行化执行 Update。对于中等并发（如几百 QPS）完全足够，简单有效。

---

## 3. 缓存层解决方案 (Redis)

当并发达到数千甚至上万 QPS 时，直接打数据库会导致数据库宕机。必须将**库存扣减前置到 Redis**。

### ❌ 简单的 Redis Get/Set
```java
int stock = redis.get("stock");
if (stock > 0) {
    redis.set("stock", stock - 1);
    // 依然存在并发间隙，导致超卖
}
```

### ✅ Redis + Lua 脚本 (原子性)
Redis 自身是单线程执行的，利用 Lua 脚本将 "检查库存" 和 "扣减库存" 打包成一个原子操作。

**Lua 脚本示例：**
```lua
if (redis.call('get', KEYS[1]) == false) then return -1 end
local stock = tonumber(redis.call('get', KEYS[1]))
if (stock > 0) then
    redis.call('decr', KEYS[1])
    return 1 -- 扣减成功
else
    return 0 -- 库存不足
end
```

Java 调用侧只需判断 Lua 脚本返回值：
*   返回 1：扣减成功，允许生成订单。
*   返回 0：秒杀结束。

---

## 4. 架构层优化：削峰填谷

Redis 扣减成功后，如何安全写入数据库？

### 引入消息队列 (MQ)
秒杀本质是仅有少量用户能成功。
1.  **用户请求** -> **Redis (Lua)** 扣减库存。
    *   失败：直接返回“秒杀结束”。
    *   成功：发送“创建订单”消息到 MQ (Kafka / RocketMQ)。
2.  **消费者** -> **数据库** 异步写入订单并真实扣减 DB 库存。

**优势**：
*   **保护数据库**：DB 只承受库存数量的写压力，而非用户请求数量。
*   **提升响应速度**：前端只依赖 Redis 响应。

---

## 5. 其他防御手段

除了核心扣减逻辑，还需要外围防护：

*   **限流 (Rate Limiting)**：Nginx 或 Sentinel 限制单 IP / 单用户频率，丢弃多余请求。
*   **隐藏秒杀地址**：防止脚本提前请求，按钮点击后才动态获取秒杀 URL。
*   **验证码**：平滑流量，防止机器刷单。

## 总结

1.  **并发低**：数据库 SQL `UPDATE ... WHERE quantity > 0`。
2.  **并发高**：**Redis Lua 脚本预减库存** + **MQ 异步落库** + **数据库乐观锁兜底**。
