---
layout: post
title: Mysql的锁
---

MySQL 的锁机制是数据库性能调优和并发控制中的核心。我们可以从以下几个维度来了解 MySQL 中的锁。

---

## 一、MySQL 中的锁分类

MySQL 常见的锁主要包括：

### 1. **全局锁（Global Lock）**
- 作用范围：整个数据库实例。
- 常用语句：`FLUSH TABLES WITH READ LOCK;`
- 使用场景：做全库备份时，防止数据变化。

---

### 2. **表级锁（Table Lock）**
- 锁粒度大，开销小，冲突多，适用于读多写少的场景。
- 类型：
  - **读锁（共享锁，SHARE）**
  - **写锁（排他锁，EXCLUSIVE）**
- 示例：
  ```sql
  LOCK TABLES user READ;  -- 加共享锁
  LOCK TABLES user WRITE; -- 加排他锁
  ```

---

### 3. **行级锁（Row Lock）**（InnoDB 特有）
- 锁粒度小，开销大，冲突少。
- 依赖于索引：**InnoDB 的行锁是通过索引加锁实现的！**
- 类型：
  - **共享锁（S）**：`SELECT ... LOCK IN SHARE MODE`
  - **排他锁（X）**：`SELECT ... FOR UPDATE`

---

### 4. **意向锁（Intention Lock）**
- 表级锁，用于协调行级锁和表级锁之间的冲突。
- 自动加锁，用户不可显式控制。
- 分为：意向共享锁（IS）、意向排他锁（IX）

---

## 二、结合 SQL 语句讲解

我们用你给的表来说明，假设表结构如下：

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  name VARCHAR(100)
) ENGINE=InnoDB;
```

### 语句一：

```sql
SELECT * FROM user WHERE id = 1;
```

#### 情况 1：普通 SELECT，不带锁
- 如果没有显式加锁，这只是一个快照读（**一致性读**），**不会加行锁**。
- InnoDB 会使用 MVCC（多版本并发控制）来实现数据一致性。

#### 情况 2：带锁的 SELECT
```sql
SELECT * FROM user WHERE id = 1 FOR UPDATE; -- 或者 LOCK IN SHARE MODE
```
- **这个会加行锁（排他锁）**，锁住 `id = 1` 这一行。
- 但前提是 **必须命中索引**，也就是 `id` 是主键，用了索引，锁才是“行锁”。
- 如果 `id` 上没有索引，这会变成**表锁**！

---

### 语句二：

```sql
SELECT * FROM user WHERE id = 3 FOR UPDATE;
```

#### 情况：`id = 3` **不存在**
- MySQL 会加一个**间隙锁（Gap Lock）**，防止其他事务插入 `id = 3`。
- 这是 InnoDB 的一个特性，属于 **“Next-Key Lock（记录锁 + 间隙锁）”** 的一部分。
- 这样可以保证可重复读隔离级别下的一致性。

---

## 三、总结：是否加锁的判断逻辑

| SQL 语句 | 是否加锁 | 锁类型             | 说明 |
|----------|-----------|--------------------|------|
| `SELECT * FROM user WHERE id = 1` | 否 | 无锁 / MVCC快照读 | 默认读快照，不加锁 |
| `SELECT * FROM user WHERE id = 1 FOR UPDATE` | 是 | 行锁（排他锁） | 如果行存在，锁住该行 |
| `SELECT * FROM user WHERE id = 3 FOR UPDATE` | 是 | 间隙锁 | 行不存在，加间隙锁防插入 |
| `UPDATE user SET name='a' WHERE id = 1` | 是 | 行锁 | 锁住目标行进行修改 |
| `DELETE FROM user WHERE id = 1` | 是 | 行锁 | 删除也需要锁定目标行 |
| `INSERT INTO user (id, name) VALUES (1, 'x')` | 是 | 插入意向锁 | 对插入位置加锁，可能阻塞间隙锁 |

---

## 四、InnoDB 加锁依赖索引！

> 🔥 **重点：如果 SQL 没走索引（如全表扫描），InnoDB 可能会退化为表锁！**

- **建议**：所有需要加锁的查询（`FOR UPDATE`、更新、删除）都必须确保走索引，才能发挥 InnoDB 行锁的优势。

---

## 五、结尾

你刚才的理解已经非常接近了，补上关键点是：

- **聚簇索引快，是因为不回表；而锁是因为并发控制**。
- 对于并发写入场景，一定要结合“锁 + 事务隔离级别 + 索引”一起看。

如果你想要更深入掌握锁的实际行为，也可以用：

```sql
SHOW ENGINE INNODB STATUS;
```

来观察当前事务和锁的状态，帮助分析死锁、阻塞等问题。

---

# 查询一个不存在的索引项
这个问题问得非常深入，而且确实是很多人在理解 **间隙锁（Gap Lock）** 时容易误解的一点。我们可以用一句话回答你的疑问，然后再详细拆开解释：

---

### ✅ 简洁回答：

> **查询一个不存在的索引项 ≠ 锁住整个表**，**但可能会锁住一个“很大的间隙”，进而影响并发性能，看起来像是锁了整个表。**

---

## 🧠 来详细看看为什么你会有“锁了整个表”的感觉：

### 💡 假设你执行的是：

```sql
SELECT * FROM user WHERE id = 999 FOR UPDATE;
```

#### 情况一：表中只有一条数据，id = 1

InnoDB 的聚簇索引是有序的（B+ 树），所以结构如下：

```text
[1]
```

那么 B+ 树节点之间的间隙是：

```text
(-∞, 1)   (1, +∞)
```

查询 `id = 999`，会命中的是 `(1, +∞)` 间隙，**InnoDB 会给这个间隙加间隙锁**，防止别的事务在这里插入数据（比如 id = 2、3、999...）。

所以虽然你只查了一个不存在的 id，但结果是：**锁住了所有 id > 1 的插入** —— 这看起来像是锁了“表的下半部分”。

---

### 🔥 再极端一点：如果表中没有任何数据呢？

查询：

```sql
SELECT * FROM user WHERE id = 1 FOR UPDATE;
```

因为根本没有记录，那 InnoDB 会锁住什么？

👉 它会锁住整个索引范围，也就是 `(-∞, +∞)`，这个间隙锁会阻止任何插入。

这时候，**确实是“锁住了整个表的插入”行为**，因为不存在的值只能通过间隙锁防止别人插入它。

---

## 🤔 那么，锁住范围的大小是谁决定的？

- 是 **根据你用的查询语句** 和 **索引树结构** 决定的；
- 并不是说“查不到记录就锁整个表”，而是：
  > “查不到记录” ⇒ 锁住该记录**理论上应该落在的范围**。

也就是说：
- 查询不存在的 `id = 999`，如果最大 id 是 10，锁住的是 `(10, +∞)`；
- 查询不存在的 `id = -5`，锁住的是 `(-∞, 最小 id)`；
- 如果没有任何记录，那锁的是整个表的索引空间（确实非常像“锁了表”）。

---

## 🧩 那为什么非聚簇索引也会这样？

因为：
- InnoDB 的所有索引（包括辅助索引）都基于 B+ 树；
- 查询 `WHERE name = 'Tom' FOR UPDATE`，如果 `name` 是有索引的，就会在这个索引树中查；
- 如果查不到，就锁这个 name 应该出现的位置的间隙，**也是间隙锁**。

---

## 🚨 这是不是一个坑？

是的！在高并发系统里，很多人因为这个行为导致 **插入冲突**、**事务阻塞**、**并发插入性能极差**。

### ➤ 举个例子：

```sql
-- 事务 A
SELECT * FROM order WHERE order_id = 999 FOR UPDATE;

-- 事务 B
INSERT INTO order (order_id, ...) VALUES (999, ...);  -- 会阻塞！

-- 事务 C
INSERT INTO order (order_id, 1000); -- 也会阻塞！
```

看起来事务 A 查的只是一个不存在的值，结果 **锁住了“未来可能所有的值”**。

---

## ✅ 如何避免这类问题？

1. **只在必要的时候使用 `FOR UPDATE` 或 `LOCK IN SHARE MODE`**
2. 使用 **主键等值查询时锁的粒度最小**（不会加间隙锁）：
   ```sql
   SELECT * FROM table WHERE id = 1 FOR UPDATE;  -- 若存在，只加记录锁
   ```
3. 对不存在值的加锁，应考虑：
   - 是否真的需要用 `FOR UPDATE`
   - 是否能用业务层逻辑防止并发写入

---

## ✅ 总结一句话：

> 查询一个不存在的索引项，不是锁整个表，但可能锁住一个很大的范围（甚至是整个索引空间），导致后续插入被阻塞，表现上像“锁了整个表”。

---

如果你愿意，我可以写一个用 MySQL 两个事务演示“锁不存在记录导致阻塞”的实际案例，让你更直观地体会这个现象。要不要？