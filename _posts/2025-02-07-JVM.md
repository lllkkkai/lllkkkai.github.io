---
layout: post
category: JVM
---

# JVM拆解
Java语言设计的初衷：**一次编写，处处运行(Write Once, Run Anywhere)**

为了实现目标，JVM诞生了。（Java Virtual Machine）是Java程序的运行环境，它负责将Java字节码转换为特定平台的机器指令，从而实现跨平台的能力。

HotSpot VM，OracleJDK（商用）和 OpenJDK（开源）的默认虚拟机，也是目前使用最广泛的 Java 虚拟机。

> HotSpot 的技术优势就在于热点代码探测技术（名字就从这来的）和准确式内存管理技术。
> 
> 热点代码探测：通过执行计数器找出最具有编译价值的代码，然后通知即时编译器以方法为单位进行编译，解释器就可以不再逐行的将字节码翻译成机器码，而是将一整个方法的所有字节码翻译成机器码再执行。

## JVM的组成：
- 类加载器
- 运行时数据区（堆栈这些内存部分）
- 执行引擎（将字节码指令解释为各自平台上的机器指令）

## Java文件是如何被运行的

1. **编译与类加载**  
   当我们编写好 `App.java` 文件并通过 `javac` 编译后，会生成对应的 `App.class` 字节码文件。执行 `App.class` 时，系统会启动一个 JVM 进程。JVM 会从类路径（classpath）中查找名为 `App.class` 的二进制文件，并将其加载到运行时数据区的方法区（Method Area）中。这个过程称为 **类的加载**。  
   - **方法区**：用于存储类的元数据（如类名、父类、接口、字段、方法信息等）、常量池、静态变量以及即时编译器编译后的代码。它是所有线程共享的内存区域。
> 元数据：
> 类的元数据是描述类本身信息的数据，这些信息不是类所代表的业务逻辑数据，而是关于类的结构、属性、方法、注解等方面的描述。
> #### 1. 类的基本信息
>- **类名**：类的全限定名，包含包名和类名，如 `java.util.ArrayList`。它唯一标识了一个类，在 Java 的类加载、反射等机制中起到关键作用。
>- **父类信息**：指明该类继承自哪个父类。Java 是单继承的，每个类（除 `Object` 类外）都有且仅有一个直接父类。例如，`ArrayList` 类的父类是 `AbstractList`。
>- **接口信息**：列出该类实现的所有接口。一个类可以实现多个接口，通过实现接口，类可以具备某些特定的行为。例如，`ArrayList` 实现了 `List`、`RandomAccess` 等接口。
>#### 2. 成员变量信息
>- **变量名**：类中定义的成员变量的名称，用于在类的内部和外部引用这些变量。
>- **数据类型**：成员变量的数据类型，如 `int`、`String`、自定义类等。它决定了变量可以存储的数据范围和操作。
>- **访问修饰符**：指定成员变量的访问权限，如 `private`、`protected`、`public` 等。不同的访问修饰符控制了变量在不同作用域内的可见性。
>#### 3. 方法信息
>- **方法名**：类中定义的方法的名称，用于调用该方法执行特定的功能。
>- **参数列表**：方法接受的参数的类型和名称。参数列表决定了调用方法时需要传递的数据。
>- **返回类型**：方法执行后返回的数据类型。如果方法不返回任何值，则返回类型为 `void`。
>- **访问修饰符**：指定方法的访问权限，同样有 `private`、`protected`、`public` 等。
>- **方法的注解**：可以为方法添加注解，注解可以提供额外的元数据信息，用于编译时处理、运行时反射等。例如，`@Override` 注解表示该方法是重写父类的方法。
>#### 4. 注解信息
>注解是 Java 提供的一种元数据机制，它可以为类、方法、字段等添加额外的信息。注解本身并不影响程序的逻辑，但可以被编译器、开发工具或运行时环境读取和处理。例如，`@Deprecated` 注解表示该类、方法或字段已经过时，不建议再使用。
>### 元数据的作用
>#### 1. 反射机制
>Java 的反射机制允许程序在运行时动态地获取类的元数据，并可以根据这些元数据创建对象、调用方法、访问字段等。反射机制在很多框架和工具中都有广泛的应用，如 Spring 框架通过反射机制实现依赖注入、MyBatis 框架通过反射机制实现对象关系映射。
>#### 2. 代码生成和处理
>编译器和开发工具可以根据类的元数据生成代码或进行代码检查。例如，一些代码生成工具可以根据类的元数据生成接口文档、测试代码等。
>#### 3. 运行时配置和扩展
>在运行时，程序可以根据类的元数据进行配置和扩展。例如，通过读取注解信息，程序可以动态地加载和使用不同的插件或模块。
>   JVM 找到 `App` 类的主程序入口，即 `public static void main(String[] args)` 方法，并开始执行其中的代码。

3. **动态类加载与对象创建**  
   在 `main` 方法中，第一条语句 `Student student = new Student("tellUrDream");`。这条语句的作用是让 JVM 创建一个 `Student` 对象。然而，此时方法区中可能还没有 `Student` 类的信息。因此，JVM 会立即触发 `Student` 类的加载过程，将 `Student` 类的元数据（如类结构、方法表、字段信息等）加载到方法区中。  
   - **类加载的触发条件**：当程序首次使用某个类时（如创建对象、访问静态成员等），JVM 会通过类加载器（ClassLoader）加载该类的字节码文件（.class 文件）。  
   - **类加载的过程**：  
     - **加载**：通过全限定名查找类的字节码文件，并将其读入内存，生成一个 `java.lang.Class` 对象。  
     - **验证**：确保字节码文件符合 JVM 规范，防止恶意代码破坏 JVM。  
     - **准备**：为类的静态变量分配内存并赋予默认值（如 `int` 的默认值为 `0`）。  
     - **解析**：将类中的符号引用转换为直接引用。  
     - **初始化**：执行类的静态代码块（`static {}`）和静态变量的显式赋值。

4. **对象创建与内存分配**  
   加载完 `Student` 类后，JVM 会在堆（Heap）中为新的 `Student` 实例分配内存，并调用构造函数初始化该对象。这个 `Student` 实例会持有 **指向方法区中 `Student` 类的类型信息** 的引用。  
   - **堆**：所有线程共享的内存区域，用于存储对象实例。Java 世界中几乎所有的对象实例都在这里分配内存。

5. **方法调用与执行**  
   当执行 `student.sayName();` 时，JVM 会根据 `student` 对象的引用找到对应的 `Student` 实例，然后通过该实例持有的引用定位到方法区中 `Student` 类的类型信息，进而找到 `sayName()` 方法的字节码地址并执行。

---

### 总结
Java 文件的运行过程可以概括为以下几个步骤：  
1. **编译**：将 `.java` 文件编译为 `.class` 字节码文件。  
2. **类加载**：JVM 加载 `.class` 文件，将类信息存储到方法区。  
3. **执行主程序**：JVM 找到 `main` 方法并执行其中的代码。  
4. **动态类加载与对象创建**：在需要时加载其他类，并在堆中创建对象实例。  
5. **方法调用**：通过对象引用调用方法，执行对应的字节码指令。

这一过程充分体现了 JVM 的 **动态类加载机制** 和 **内存管理机制**，确保了 Java 程序的灵活性和跨平台能力。

---

### 1. **类的加载（Loading）**
- **触发条件**：当程序首次使用某个类时（例如创建对象、访问静态成员等），JVM会通过类加载器（ClassLoader）加载该类的字节码文件（.class文件）。
- **加载过程**：
  - 类加载器通过全限定名（Fully Qualified Name）查找类的字节码文件。
  - 将字节码文件读入内存，并生成一个 `java.lang.Class` 对象。
  - `Class` 对象的引用会被保存到方法区中。

---

### 2. **类的验证（Verification）**
- **目的**：确保加载的字节码文件符合JVM规范，防止恶意代码破坏JVM。
- **验证内容**：
  - 文件格式验证（是否符合Class文件格式）。
  - 元数据验证（是否符合Java语言规范）。
  - 字节码验证（确保字节码不会危害JVM的运行）。
  - 符号引用验证（确保对其他类的引用正确）。

---

### 3. **类的准备（Preparation）**
- **目的**：为类的静态变量分配内存，并赋予默认值（例如 `int` 的默认值是 `0`）。
- 如果是 `final` 修饰的常量，会在此阶段直接赋值。

---

### 4. **类的解析（Resolution）**
- **目的**：将类中的符号引用（Symbolic Reference）转换为直接引用（Direct Reference）。
- 解析过程涉及对类、方法、字段等的解析。

---

### 5. **类的初始化（Initialization）**
- **目的**：执行类的静态代码块（`static {}`）和静态变量的显式赋值。
- 初始化是一个按需延迟执行的过程，只有真正用到类时才会触发。

---

### 6. **类信息的存储**
- **存储内容**：类的元数据（包括类名、父类、接口、字段、方法信息等）和运行时常量池会被存储到方法区。
- **运行时常量池（Runtime Constant Pool）**：存储类中定义的常量、方法引用等。

---

### 总结
类信息被放入方法区的过程是通过类加载机制完成的：加载 -> 验证 -> 准备 -> 解析 -> 初始化。最终，类的元数据和运行时常量池会被存储到方法区中，供JVM运行时使用。

需要注意的是，方法区的具体实现因JVM不同而有所差异：
- 在HotSpot JVM中，方法区被称为**永久代（Permanent Generation，JDK 7及之前）** 或 **元空间（Metaspace，JDK 8及之后）**。
- 元空间使用本地内存（Native Memory），而不是JVM堆内存，因此默认情况下其大小不受`-Xmx`参数的限制。


4. 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 **指向方法区中的 Student 类的类型信息** 的引用

5. 执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。

6. 执行sayName()
## JVM的内存分配
自动内存管理的根本目标：

> **自动给对象分配内存，自动回收分配给对象的内存**

### 程序计数器 Program Counter Register

是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器

由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存

### 虚拟机栈 VM Stack

JVM Stack（Stack 或虚拟机栈、线程栈、栈）中存放的就是 Stack Frame（Frame 或栈帧、方法栈）

一个线程对应一个 JVM Stack。JVM Stack 中包含一组 Stack Frame。线程每调用一个方法就对应着 JVM Stack 中 Stack Frame 的入栈，方法执行完毕或者异常终止对应着出栈（销毁）。

当 JVM 调用一个 Java 方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入 JVM 栈中。

在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧相关联的方法称为当前方法。

### 本地方法栈 Native Method Stack

虚拟机栈是为Java方法服务，本地方法栈是为Native方法服务

### 方法区 Method Area

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载 的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。

**运行时常量池**（Runtime Constant Pool）是方法区的一部分。

### 堆 Heap

所有线程共享的内存区域，虚拟机启动时创建。存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。

堆也是垃圾收集器管理的内存区域，某些资料称它为GC堆，

根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的 内存空间。 Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。

### 直接内存（Direct Memory）

并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所 以我们放到这里一起讲解。 在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区 （Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了 在Java堆和Native堆中来回复制数据。 显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到 本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务 器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得 各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常

## 哪些区域可能会发生 OOM

### 1. 堆内存
**原因**：Java 堆是用于存储对象实例的区域。如果不断创建新的对象，并且这些对象无法被垃圾回收器及时回收，堆内存就会不断被占用，直到达到堆的最大限制，从而引发 OOM。这通常是由于内存泄漏（对象不再使用但仍然被引用）或者对象创建过多导致的。

**示例场景**：
- **内存泄漏**：在一个 Web 应用中，如果在每次处理请求时都创建新的对象，并且这些对象的引用被错误地保留在某个静态集合中，随着请求的不断增加，堆内存会逐渐被耗尽。
- **对象创建过多**：例如在一个数据处理程序中，一次性加载大量的数据到内存中，创建大量的对象，而堆内存不足以容纳这些对象，就会导致 OOM。

**异常信息**：`java.lang.OutOfMemoryError: Java heap space`

### 2. Java 虚拟机栈和本地方法栈
**原因**：虚拟机栈和本地方法栈是线程私有的，每个线程在执行方法时会创建栈帧，栈帧中存储着局部变量表、操作数栈等信息。如果线程请求的栈深度超过了虚拟机所允许的最大深度，就会抛出 `StackOverflowError`；如果虚拟机栈可以动态扩展，并且在扩展时无法申请到足够的内存，就会抛出 OOM。

**示例场景**：
- **栈深度过大**：在递归调用方法时，如果没有正确的终止条件，会导致方法不断递归调用，栈帧不断入栈，最终栈深度超过限制，抛出 `StackOverflowError`。
- **线程创建过多**：每个线程都需要占用一定的栈空间，如果创建了大量的线程，会导致栈空间耗尽，从而引发 OOM。

**异常信息**：
- **栈深度过大**：`java.lang.StackOverflowError`
- **栈扩展失败**：`java.lang.OutOfMemoryError: unable to create new native thread`

### 3. 直接内存
**原因**：直接内存并不是 JVM 运行时数据区的一部分，但在 NIO（New Input/Output）中，会使用 `DirectByteBuffer` 类直接分配堆外内存。如果直接内存的分配量超过了系统的可用内存，就会导致 OOM。

**示例场景**：在使用 NIO 进行文件读写或者网络通信时，如果频繁创建 `DirectByteBuffer` 对象，并且没有及时释放这些对象所占用的内存，会导致直接内存不断增长，最终引发 OOM。

**异常信息**：`java.lang.OutOfMemoryError: Direct buffer memory`

### 4. 方法区
**永久代（JDK 1.8 之前）**：永久代用于存储类的元数据、常量池、静态变量等信息。如果加载的类过多，或者常量池中的常量过多，会导致永久代空间不足，从而引发 OOM。

**元空间（JDK 1.8 及以后）**：元空间使用本地内存来存储类的元数据，默认情况下只受限于系统的可用内存。但如果加载了大量的类，或者元空间的大小设置不合理，也可能会导致元空间内存不足，抛出 OOM。

**示例场景**：
- **动态类加载**：在一些框架（如 Spring、Hibernate 等）中，会动态加载大量的类。如果这些类没有被正确卸载，会导致元空间不断增长，最终引发 OOM。
- **常量池过大**：在代码中使用了大量的字符串常量，或者通过反射创建了大量的常量对象，会导致常量池占用过多的空间，从而引发 OOM。

**异常信息**：
- **永久代**：`java.lang.OutOfMemoryError: PermGen space`
- **元空间**：`java.lang.OutOfMemoryError: Metaspace`

## JVM占用内存为何会超过Xmx

Xmx只控制java heap，还有堆外、线程等占用的空间。

Java8给HotSpot VM引入了Native Memory Tracking (NMT)特性，可以用于追踪JVM的内部内存使用，一般在压测调参的时候使用，生产环境不要引入，根据Java官方文档，开启NMT会有5%－10%的性能损耗。
设置启动参数，
-XX:NativeMemoryTracking=detail
开启NMT。使用NMT查询jvm内存使用情况，执行命令
jcmd 573 VM.native_memory summary scale=MB

从NMT的结果，可以看到整个memory主要包含了Java Heap、Class、Thread、Code、GC、Internal、Symbol、Native Memory Tracking这几部分。（reserved表示应用可用的内存大小，committed表示应用正在使用的内存大小）。

- Java Heap: 堆内存，即 -Xmx 限制的最大堆大小的内存。
- Class：加载的类与方法信息，即metaspace，包含两部分：一是 metadata，被 -XX:MaxMetaspaceSize 限制最大大小，另外是 class space，被 -XX:CompressedClassSpaceSize 限制最大大小
- Thread：线程与线程栈占用内存，每个线程栈占用大小受 -Xss 限制，但是总大小没有限制。
- Code：JIT 即时编译后（C1 C2 编译器优化）的代码占用内存，受 -XX:ReservedCodeCacheSize 限制
- GC：垃圾回收占用内存，例如垃圾回收需要的 CardTable，标记数，区域划分记录，还有标记 GC Root 等等，都需要内存。
- Internal：命令行解析，JVMTI 使用的内存，这个不受限制，一般不会很大的
- Symbol: 常量池占用的大小，字符串常量池受 -XX:StringTableSize 个数限制，总内存大小不受限制
- Native Memory Tracking：内存采集本身占用的内存大小

这里也就解释了为何Jvm占用内存会超过 Xmx，Xmx只控制java heap，还有堆外、线程等占用的空间。

## 问题汇总

### **一、基础概念与内存模型**
1. **JVM内存区域划分**  
   - 描述JVM运行时数据区的组成部分（堆、栈、方法区等）？  
   - 哪些区域是线程共享的？哪些是线程私有的？  
   - 元空间（Metaspace）和永久代（PermGen）的区别？为什么要替换？
   > 永生代在内存管理、性能和灵活性方面的局限性。通过使用本地内存和动态调整大小，元空间提供了更高效、更灵活的内存管理方式，适应了现代应用程序(现代应用程序（如Spring、Hibernate等框架）大量使用动态类加载和反射，导致类的元数据频繁变化)的需求。
   > 为什么动态类加载和反射会导致元数据频繁变化？
   > 动态类加载和反射是Java中非常强大的特性，它们允许程序在运行时动态地加载类、创建对象、调用方法等。这些特性在现代框架（如Spring、Hibernate等）中广泛使用，但也导致了类的元数据频繁变化。以下是具体原因：

#### 1. **动态类加载**
动态类加载是指在程序运行时根据需要加载类，而不是在程序启动时一次性加载所有类。这种方式在以下场景中非常常见：
- **插件化架构**：应用程序可以通过加载不同的插件来扩展功能，每个插件可能包含新的类。
- **热部署**：在开发或生产环境中，应用程序可以在不重启的情况下加载新的类或更新已有的类。
- **延迟加载**：某些类只有在真正需要时才会被加载，以减少启动时间和内存占用。

**导致元数据频繁变化的原因**：
- 每次动态加载一个新类时，JVM需要为该类生成元数据（如类结构、方法信息、字段信息等），并将其存储在元空间中。
- 如果应用程序频繁加载和卸载类，元空间中的元数据会不断变化，导致元数据的频繁更新和回收。

#### 2. **反射**
反射是指在运行时动态地获取类的信息并操作类的成员（如字段、方法、构造函数等）。反射在以下场景中非常有用：
- **框架和库**：许多框架（如Spring、Hibernate）使用反射来实现依赖注入、对象关系映射（ORM）等功能。
- **动态代理**：通过反射可以动态创建代理对象，用于实现AOP（面向切面编程）等功能。
- **通用工具**：反射可以用于编写通用的工具类，如序列化、反序列化工具。

**导致元数据频繁变化的原因**：
- 反射操作通常需要访问类的元数据（如方法、字段等），这可能导致JVM在运行时动态生成或修改元数据。
- 反射还可能触发类的延迟加载，即在使用反射访问某个类时，如果该类尚未加载，JVM会先加载该类并生成相应的元数据。

#### 3. **元数据的生命周期**
- **类加载**：当一个类被加载时，JVM会为其生成元数据并存储在元空间中。
- **类卸载**：当一个类不再被引用时（即其类加载器被回收），JVM会卸载该类并释放其元数据。
- **频繁加载和卸载**：在动态类加载和反射的场景下，类的加载和卸载可能非常频繁，导致元数据的生命周期变短，元空间中的元数据频繁变化。

#### 总结
动态类加载和反射导致元数据频繁变化的主要原因包括：
- **动态加载新类**：每次加载新类时，JVM需要生成并存储元数据。
- **反射操作**：反射可能触发类的延迟加载和元数据的动态生成。
- **频繁加载和卸载**：在动态类加载和反射的场景下，类的加载和卸载频率较高，导致元数据的生命周期变短。

这些特性使得元空间的设计（动态调整大小、使用本地内存等）成为必要，以更好地适应现代应用程序的需求。

2. **对象的生命周期**  
   - 对象的创建过程（如何分配内存、如何初始化）？  
   - 对象访问的两种方式（句柄池 vs 直接指针）的优缺点？

3. **Java内存模型（JMM）**  
   - 什么是可见性、有序性、原子性？  
   - volatile关键字的作用？如何实现内存屏障？  
   - Happens-Before规则举例说明？

---

### **二、垃圾回收（GC）**
4. **GC基础与算法**  
   - 如何判断对象是否可回收（引用计数 vs 可达性分析）？  
   - 常见的GC算法（标记-清除、复制、标记-整理、分代）的优缺点？  
   - 什么是跨代引用？如何解决？

5. **垃圾收集器**  
   - CMS和G1的差异？分别适用什么场景？  
   - 为什么CMS会被标记为废弃？ZGC/Shenandoah的核心优化是什么？  
   - 如何选择垃圾收集器（如低延迟场景下推荐什么）？

6. **GC调优实战**  
   - 遇到Full GC频繁如何排查？可能的原因（内存泄漏、大对象、元空间不足等）？  
   - 如何通过日志（如-XX:+PrintGCDetails）分析GC问题？  
   - 常见的JVM参数（堆大小、Young/Old区比例、Survivor区调整）如何配置？

---

### **三、类加载与字节码**
7. **类加载机制**  
   - 双亲委派机制的原理和意义？如何打破双亲委派（如Tomcat类加载机制）？  
   - 什么是SPI机制？JDBC如何通过破坏双亲委派加载驱动类？

8. **字节码与优化**  
   - JIT编译器的核心优化手段（逃逸分析、方法内联、锁消除等）？  
   - 如何通过反编译工具（javap）分析字节码指令？

---

### **四、性能调优与监控**
9. **OOM问题诊断**  
   - 遇到OutOfMemoryError如何定位？不同错误类型（堆、栈、元空间、直接内存）的排查思路？  
   - 如何通过MAT或JProfiler分析堆转储文件（hprof文件）？

10. **工具使用**  
    - 如何通过jstat、jmap、jstack排查问题？  
    - JFR（Java Flight Recorder）如何开启？能记录哪些关键事件？  
    - Arthas的热更新或动态监控能力如何实现？

11. **线程与锁机制**  
    - 如何通过JVM定位死锁（jstack或其他工具）？  
    - 偏向锁、轻量级锁、重量级锁的升级过程？  
    - synchronized和Lock的区别（底层实现、性能）？  

---

### **五、开放性问题**
12. **实战场景分析**  
    - 如果系统在高并发下出现长时间停顿，可能有哪些JVM层面的原因？  
    - 如何设计一个避免Full GC的系统（考虑堆外内存、对象池化等）？  
    - 你优化过哪些JVM参数？背后的逻辑是什么？

13. **新技术了解**  
    - 是否了解GraalVM？它的AOT编译对JVM有何影响？  
    - 如何评价ZGC的低延迟特性（Region设计、染色指针、读屏障等）？  

---

### **评价标准**：
- **基础扎实度**：能否清晰描述JVM核心机制，避免概念混淆。  
- **问题分析能力**：对实际场景的解决思路是否逻辑清晰。  
- **调优经验**：是否具备参数调优、工具使用和性能优化的实战经验。  
- **技术前瞻性**：对现代GC算法或新技术的了解是否深入。  