---
layout: post
title: Mysql合订版
---
## 隔离级别与ACID
- 原子性（undolog事务开始的时候记录数据修改前的旧值，与数据页一起持久化到磁盘，如果事务失败，通过undo log回滚）
- 持久性（redolog先写入磁盘，再写入数据页）
- 隔离性（MVVC（并发读）（每行数据三个隐藏字段））
- 一致性（以上全部）
### 隔离级别
- 读未提交（RU）
- 读已提交（RC）（每次select创建新的Read View，可能出现不可重复读）
- 可重复读（RR）（事务开始的时候创建Read View，整个事务都用这个Read View，看不到事务开始后其他事务的提交的修改）依靠MVVC和锁（并发写）解决幻读
- 串行化（SI）

## 锁
- 记录锁
- 乐观锁
- 表锁
- 间隙锁
- 行锁
- 临键锁
- 共享锁

## 索引
- b树和b+树的区别（b+树只在叶子节点存数据，叶子节点有双向链表方便从头到尾扫描）
### 索引失效的场景
- 低选择性列建立索引（性别、布尔类型）
- VARCHAR类型但是查询条件使用的是数字类型，导致隐式转换（WHERE name = 123）
- 使用了函数或运算导致索引失效（SELECT * FROM users WHERE YEAR(create_time) = 2023）
- 非索引列 OR 条件	（）WHERE id=1 OR name='John' (name 无索引)）
- 复合不符合最左匹配原则
### 使用了索引但是查询速度很慢（索引失效）

### like查询会使用到索引吗？
会，

## 主从复制
1. 主库写入数据，记录binlog
   [主库] → 写数据 → 记录binlog日志
2. 从库连接主库，请求binlog
   [从库] → 通过IO线程 → 请求binlog
3. 主库发送binlog
   [主库] → 通过dump线程 → 发送binlog
4. 从库接收并存储
   [从库] → 通过IO线程 → 存储为relay log（中继日志）
5. 从库回放日志
   [从库] → 通过SQL线程 → 回放relay log → 保持数据同步
### 两个关键线程
- IO线程：负责从主库拉取binlog
- SQL线程：负责回放relay log
### 两个关键日志 ：
- binlog：主库的变更日志
- relay log：从库的中继日志

## sql优化
1. 避免全表扫描
2. 避免使用子查询
3. 避免使用or
4. 避免使用like
5. 避免使用distinct
6. 避免使用*

### sql调优场景
已经使用了索引如何优化查询速度？

索引的本质是一颗B+树，树的高度会觉得磁盘IO的速度，对查询语句优化的本质，意味着使用最快的速度去找到索引的位置

1. 回表操作过多
2. 索引选择性低
3. 数据量过大，导致索引层级过高
4. 大量范围查询
5. 可能存在锁竞争
6. 服务器内存配置问题，需要频繁IO

## 生产环境慢SQL完整排查指南

作为开发人员，当收到生产环境慢SQL告警时，需要系统化地进行排查和优化。以下是完整的处理流程。

### 第一步：发现和定位慢SQL

#### 1.1 通过慢查询日志定位

**开启慢查询日志**

```sql
-- 查看是否开启慢查询日志
SHOW VARIABLES LIKE 'slow_query_log';

-- 开启慢查询日志
SET GLOBAL slow_query_log = 'ON';

-- 设置慢查询阈值（单位：秒）
SET GLOBAL long_query_time = 2;

-- 查看慢查询日志文件位置
SHOW VARIABLES LIKE 'slow_query_log_file';
```

**分析慢查询日志**

```bash
# 使用 mysqldumpslow 工具分析
mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

# 参数说明：
# -s t: 按查询时间排序
# -t 10: 显示前10条
# -s c: 按查询次数排序
# -s l: 按锁定时间排序
```

#### 1.2 通过监控工具发现

- **APM工具**: 如 Skywalking、Pinpoint、Cat 等
- **数据库监控**: 如 Prometheus + Grafana
- **云平台监控**: 阿里云RDS、腾讯云CDB 等自带的慢SQL分析

#### 1.3 实时查看正在执行的SQL

```sql
-- 查看当前正在执行的SQL
SHOW PROCESSLIST;

-- 或使用完整信息
SHOW FULL PROCESSLIST;

-- 查看特定时间以上的查询
SELECT * FROM information_schema.PROCESSLIST 
WHERE TIME > 5 AND COMMAND != 'Sleep';
```

### 第二步：SQL执行计划分析

使用 `EXPLAIN` 分析SQL执行计划，这是最重要的优化工具。

```sql
EXPLAIN SELECT * FROM orders WHERE user_id = 123 AND status = 1;
```

#### 2.1 关键字段解读

| 字段 | 说明 | 重点关注 |
|------|------|----------|
| **type** | 访问类型 | 性能从好到差：system > const > eq_ref > ref > range > index > ALL |
| **possible_keys** | 可能使用的索引 | 有索引但未使用，需排查原因 |
| **key** | 实际使用的索引 | NULL表示未使用索引 |
| **key_len** | 索引使用长度 | 复合索引是否充分利用 |
| **rows** | 扫描行数 | 值越大性能越差 |
| **Extra** | 额外信息 | 关注 Using filesort、Using temporary |

#### 2.2 常见问题识别

**问题1: type = ALL (全表扫描)**
```sql
-- 问题SQL
EXPLAIN SELECT * FROM users WHERE name = 'John';
-- type: ALL, rows: 100000

-- 解决方案：添加索引
CREATE INDEX idx_name ON users(name);
```

**问题2: Extra = Using filesort (文件排序)**
```sql
-- 问题SQL
EXPLAIN SELECT * FROM orders ORDER BY create_time;
-- Extra: Using filesort

-- 解决方案：在排序字段上创建索引
CREATE INDEX idx_create_time ON orders(create_time);
```

**问题3: Extra = Using temporary (使用临时表)**
```sql
-- 问题SQL
EXPLAIN SELECT status, COUNT(*) FROM orders GROUP BY status;
-- Extra: Using temporary

-- 解决方案：优化GROUP BY或添加索引
CREATE INDEX idx_status ON orders(status);
```

### 第三步：深入分析SQL性能

#### 3.1 使用 EXPLAIN ANALYZE (MySQL 8.0+)

```sql
-- 获取实际执行时间和成本
EXPLAIN ANALYZE 
SELECT * FROM orders 
WHERE user_id = 123 AND create_time > '2024-01-01';
```

#### 3.2 查看SQL详细执行统计

```sql
-- 开启 profiling
SET profiling = 1;

-- 执行要分析的SQL
SELECT * FROM orders WHERE user_id = 123;

-- 查看执行耗时
SHOW PROFILES;

-- 查看详细的执行过程
SHOW PROFILE FOR QUERY 1;

-- 查看CPU、IO等资源消耗
SHOW PROFILE CPU, BLOCK IO FOR QUERY 1;
```

#### 3.3 检查索引统计信息

```sql
-- 查看表的索引信息
SHOW INDEX FROM orders;

-- 查看索引基数（Cardinality）
-- 基数越高，索引选择性越好
ANALYZE TABLE orders;
SHOW INDEX FROM orders;
```

### 第四步：常见慢SQL场景及解决方案

#### 4.1 索引失效场景

**场景1: 索引列使用函数**

```sql
-- ❌ 错误写法（索引失效）
SELECT * FROM users WHERE YEAR(create_time) = 2024;

-- ✅ 正确写法
SELECT * FROM users 
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01';
```

**场景2: 隐式类型转换**

```sql
-- ❌ 错误写法（phone是VARCHAR，但用数字查询）
SELECT * FROM users WHERE phone = 13800138000;

-- ✅ 正确写法
SELECT * FROM users WHERE phone = '13800138000';
```

**场景3: 前导模糊查询**

```sql
-- ❌ 错误写法（无法使用索引）
SELECT * FROM users WHERE name LIKE '%John%';

-- ✅ 优化方案1：使用后缀匹配
SELECT * FROM users WHERE name LIKE 'John%';

-- ✅ 优化方案2：使用全文索引
ALTER TABLE users ADD FULLTEXT INDEX idx_name_fulltext(name);
SELECT * FROM users WHERE MATCH(name) AGAINST('John');
```

**场景4: 复合索引不遵循最左匹配**

```sql
-- 复合索引：INDEX idx_abc (a, b, c)

-- ❌ 错误写法（跳过了a）
SELECT * FROM table WHERE b = 1 AND c = 2;

-- ✅ 正确写法
SELECT * FROM table WHERE a = 1 AND b = 1 AND c = 2;
```

#### 4.2 回表过多导致慢查询

**问题分析**
```sql
-- 二级索引 + 回表查询全部字段
EXPLAIN SELECT * FROM orders WHERE user_id = 123;
-- Extra: Using index condition (需要回表)
```

**解决方案：使用覆盖索引**
```sql
-- 方案1: 只查询必要字段
SELECT id, user_id, order_no, total_amount 
FROM orders WHERE user_id = 123;

-- 方案2: 创建覆盖索引（包含查询的所有字段）
CREATE INDEX idx_user_cover ON orders(user_id, order_no, total_amount);
```

#### 4.3 深分页问题

**问题SQL**
```sql
-- 越往后翻页越慢
SELECT * FROM orders ORDER BY id LIMIT 1000000, 20;
-- 需要扫描1000020行数据
```

**解决方案**

```sql
-- 方案1: 使用上次查询的最大ID
SELECT * FROM orders 
WHERE id > 1000000 
ORDER BY id LIMIT 20;

-- 方案2: 延迟关联（先查ID，再关联）
SELECT a.* FROM orders a
INNER JOIN (
    SELECT id FROM orders ORDER BY id LIMIT 1000000, 20
) b ON a.id = b.id;

-- 方案3: 使用游标分页（适合导出场景）
-- 前端记录上次最后一条记录的ID
SELECT * FROM orders 
WHERE id > #{lastId} 
ORDER BY id LIMIT 20;
```

#### 4.4 大表JOIN优化

**问题SQL**
```sql
-- 大表关联查询
SELECT o.*, u.name 
FROM orders o 
LEFT JOIN users u ON o.user_id = u.id
WHERE o.create_time > '2024-01-01';
```

**优化方案**

```sql
-- 1. 确保关联字段有索引
CREATE INDEX idx_user_id ON orders(user_id);
CREATE INDEX idx_id ON users(id);  -- 主键默认有索引

-- 2. 小表驱动大表（如果是INNER JOIN）
-- MySQL优化器通常会自动选择，但可以手动指定
SELECT STRAIGHT_JOIN o.*, u.name 
FROM users u 
INNER JOIN orders o ON o.user_id = u.id
WHERE o.create_time > '2024-01-01';

-- 3. 避免使用 SELECT *
SELECT o.id, o.order_no, u.name 
FROM orders o 
LEFT JOIN users u ON o.user_id = u.id
WHERE o.create_time > '2024-01-01';
```

#### 4.5 IN查询数据过多

**问题SQL**
```sql
-- IN中有大量数据
SELECT * FROM orders WHERE user_id IN (1,2,3,...,10000);
```

**优化方案**

```sql
-- 方案1: 分批查询
-- 将10000个ID分成多批，每批500个
SELECT * FROM orders WHERE user_id IN (1,2,3,...,500);

-- 方案2: 使用临时表
CREATE TEMPORARY TABLE tmp_user_ids (user_id INT);
INSERT INTO tmp_user_ids VALUES (1),(2),(3)...(10000);
SELECT o.* FROM orders o 
INNER JOIN tmp_user_ids t ON o.user_id = t.user_id;

-- 方案3: 使用EXISTS（小数据集驱动大数据集）
SELECT * FROM orders o 
WHERE EXISTS (
    SELECT 1 FROM tmp_user_ids t WHERE t.user_id = o.user_id
);
```

#### 4.6 COUNT(*) 优化

**问题分析**
```sql
-- InnoDB存储引擎需要扫描全表
SELECT COUNT(*) FROM orders WHERE status = 1;
```

**优化方案**

```sql
-- 方案1: 添加索引（利用覆盖索引）
CREATE INDEX idx_status ON orders(status);

-- 方案2: 使用缓存
-- 将统计结果缓存到Redis，定时更新
-- 适合实时性要求不高的场景

-- 方案3: 使用汇总表
-- 创建统计表，通过触发器或定时任务维护
CREATE TABLE order_stats (
    status INT,
    count INT,
    update_time DATETIME
);
```

### 第五步：执行优化措施

#### 5.1 索引优化清单

```sql
-- 1. 为WHERE条件字段添加索引
CREATE INDEX idx_user_id ON orders(user_id);

-- 2. 为ORDER BY字段添加索引
CREATE INDEX idx_create_time ON orders(create_time);

-- 3. 创建复合索引（注意顺序）
-- 原则：等值查询 > 范围查询 > 排序
CREATE INDEX idx_composite ON orders(user_id, status, create_time);

-- 4. 创建覆盖索引（避免回表）
CREATE INDEX idx_cover ON orders(user_id, order_no, total_amount);

-- 5. 删除冗余索引
-- 如果有 INDEX(a, b, c)，则 INDEX(a) 和 INDEX(a, b) 是冗余的
SHOW INDEX FROM orders;
DROP INDEX idx_redundant ON orders;
```

#### 5.2 SQL改写技巧

```sql
-- 1. 使用 EXISTS 代替 IN
-- ❌ 慢
SELECT * FROM orders WHERE user_id IN (SELECT id FROM users WHERE level = 1);
-- ✅ 快
SELECT * FROM orders o WHERE EXISTS (
    SELECT 1 FROM users u WHERE u.id = o.user_id AND u.level = 1
);

-- 2. 避免 SELECT *
-- ❌ 慢
SELECT * FROM orders WHERE id = 123;
-- ✅ 快
SELECT id, order_no, user_id, total_amount FROM orders WHERE id = 123;

-- 3. 使用 UNION ALL 代替 UNION
-- ❌ 慢（会去重）
SELECT name FROM users WHERE age > 18
UNION
SELECT name FROM users WHERE status = 1;
-- ✅ 快（不去重）
SELECT name FROM users WHERE age > 18
UNION ALL
SELECT name FROM users WHERE status = 1;

-- 4. 拆分复杂SQL
-- 将一个复杂查询拆分成多个简单查询
-- 在应用层进行数据组装
```

#### 5.3 表结构优化

```sql
-- 1. 字段类型优化
-- ❌ 使用VARCHAR(255)存储状态
ALTER TABLE orders MODIFY status VARCHAR(255);
-- ✅ 使用TINYINT
ALTER TABLE orders MODIFY status TINYINT;

-- 2. 适当的字段长度
-- ❌ VARCHAR(500)但实际只用50
ALTER TABLE users MODIFY name VARCHAR(500);
-- ✅ 根据实际情况设置
ALTER TABLE users MODIFY name VARCHAR(100);

-- 3. 垂直分表（将大字段分离）
-- 原表：users(id, name, email, description[TEXT], content[TEXT])
-- 拆分为：
-- users(id, name, email) 
-- user_details(user_id, description, content)

-- 4. 水平分表/分库（数据量特别大时）
-- 按时间分表：orders_2024_01, orders_2024_02
-- 按ID取模：orders_0, orders_1, orders_2
```

### 第六步：验证和监控

#### 6.1 验证优化效果

```sql
-- 1. 对比优化前后的执行计划
EXPLAIN SELECT * FROM orders WHERE user_id = 123;

-- 2. 对比执行时间
SET profiling = 1;
-- 执行优化后的SQL
SELECT id, order_no FROM orders WHERE user_id = 123;
SHOW PROFILES;

-- 3. 对比扫描行数
-- 优化前：rows = 100000
-- 优化后：rows = 10
```

#### 6.2 持续监控

**设置告警**
```sql
-- 1. 慢查询日志监控
-- 设置合理的阈值
SET GLOBAL long_query_time = 1;

-- 2. 配置监控告警
-- 通过Prometheus、Grafana等工具监控
-- - 慢查询数量
-- - 平均查询时间
-- - 锁等待时间
```

**定期审查**
```sql
-- 1. 每周查看慢查询TOP10
mysqldumpslow -s t -t 10 slow.log

-- 2. 检查索引使用情况
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    SEQ_IN_INDEX,
    COLUMN_NAME,
    CARDINALITY
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'your_database';

-- 3. 查看未使用的索引
SELECT * FROM sys.schema_unused_indexes;
```

### 第七步：预防措施

#### 7.1 开发规范

1. **强制使用索引提示**
   ```sql
   -- 上线前必须执行EXPLAIN检查
   EXPLAIN SELECT * FROM orders WHERE user_id = 123;
   ```

2. **SQL审核**
   - 使用工具如Sonar、SQLReview等
   - 代码评审时重点关注SQL

3. **数据库规范**
   - 禁止使用SELECT *
   - 禁止大表不加索引
   - 限制IN列表长度（< 500）
   - 分页必须有上限（< 10000）

#### 7.2 压测验证

```bash
# 使用压测工具验证SQL性能
# sysbench、JMeter等

sysbench oltp_read_write \
  --mysql-host=localhost \
  --mysql-user=root \
  --mysql-password=password \
  --mysql-db=testdb \
  --tables=10 \
  --table-size=100000 \
  prepare
```

### 常用排查命令速查表

```sql
-- 1. 查看当前连接数
SHOW STATUS LIKE 'Threads_connected';

-- 2. 查看慢查询数量
SHOW STATUS LIKE 'Slow_queries';

-- 3. 查看锁等待
SHOW ENGINE INNODB STATUS;

-- 4. 查看表大小
SELECT 
    TABLE_NAME,
    ROUND((DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024, 2) AS 'Size(MB)'
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'your_database'
ORDER BY (DATA_LENGTH + INDEX_LENGTH) DESC;

-- 5. 查看索引大小
SELECT 
    TABLE_NAME,
    INDEX_NAME,
    ROUND(STAT_VALUE * @@innodb_page_size / 1024 / 1024, 2) AS 'Size(MB)'
FROM mysql.innodb_index_stats
WHERE DATABASE_NAME = 'your_database'
AND STAT_NAME = 'size';

-- 6. 查看碎片率
SELECT 
    TABLE_NAME,
    ROUND(DATA_FREE / 1024 / 1024, 2) AS 'Fragmentation(MB)'
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'your_database'
AND DATA_FREE > 0;
```

### 总结

慢SQL优化的核心思路：

1. **发现问题**: 慢查询日志、APM监控、实时进程
2. **分析原因**: EXPLAIN执行计划、索引统计、profiling
3. **定位瓶颈**: 扫描行数过多、索引失效、回表过多、锁等待
4. **优化措施**: 添加/优化索引、改写SQL、调整表结构
5. **验证效果**: 对比执行计划和时间、压力测试
6. **持续监控**: 定期审查、告警通知、性能趋势分析

记住：**没有银弹，具体问题具体分析，始终要结合业务场景优化。**