---
layout: post
title: Mysql合订版
---
## 隔离级别与ACID
- 原子性（undolog事务开始的时候记录数据修改前的旧值，与数据页一起持久化到磁盘，如果事务失败，通过undo log回滚）
- 持久性（redolog先写入磁盘，再写入数据页）
- 隔离性（MVVC（并发读）（每行数据三个隐藏字段））
- 一致性（以上全部）
### 隔离级别
- 读未提交（RU）
- 读已提交（RC）（每次select创建新的Read View，可能出现不可重复读）
- 可重复读（RR）（事务开始的时候创建Read View，整个事务都用这个Read View，看不到事务开始后其他事务的提交的修改）依靠MVVC和锁（并发写）解决幻读
- 串行化（SI）

## 锁
- 记录锁
- 乐观锁
- 表锁
- 间隙锁
- 行锁
- 临键锁
- 共享锁

## 索引
- b树和b+树的区别（b+树只在叶子节点存数据，叶子节点有双向链表方便从头到尾扫描）
### 索引失效的场景
- 低选择性列建立索引（性别、布尔类型）
- VARCHAR类型但是查询条件使用的是数字类型，导致隐式转换（WHERE name = 123）
- 使用了函数或运算导致索引失效（SELECT * FROM users WHERE YEAR(create_time) = 2023）
- 非索引列 OR 条件	（）WHERE id=1 OR name='John' (name 无索引)）
- 复合不符合最左匹配原则
### 使用了索引但是查询速度很慢（索引失效）

### like查询会使用到索引吗？
会，

## 主从复制
1. 主库写入数据，记录binlog
   [主库] → 写数据 → 记录binlog日志
2. 从库连接主库，请求binlog
   [从库] → 通过IO线程 → 请求binlog
3. 主库发送binlog
   [主库] → 通过dump线程 → 发送binlog
4. 从库接收并存储
   [从库] → 通过IO线程 → 存储为relay log（中继日志）
5. 从库回放日志
   [从库] → 通过SQL线程 → 回放relay log → 保持数据同步
### 两个关键线程
- IO线程：负责从主库拉取binlog
- SQL线程：负责回放relay log
### 两个关键日志 ：
- binlog：主库的变更日志
- relay log：从库的中继日志

## sql优化
1. 避免全表扫描
2. 避免使用子查询
3. 避免使用or
4. 避免使用like
5. 避免使用distinct
6. 避免使用*

### sql调优场景
已经使用了索引如何优化查询速度？

索引的本质是一颗B+树，树的高度会觉得磁盘IO的速度，对查询语句优化的本质，意味着使用最快的速度去找到索引的位置

1. 回表操作过多
2. 索引选择性低
3. 数据量过大，导致索引层级过高
4. 大量范围查询
5. 可能存在锁竞争
6. 服务器内存配置问题，需要频繁IO