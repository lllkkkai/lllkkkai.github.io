---
layout: post
category: Java
---

A Post with Header Image, See [Page layout](https://kitian616.github.io/jekyll-TeXt-theme/samples.html#page-layout) for more examples.

<!--more-->

在深入理解`volatile`关键字之前,我们需要先了解CPU与内存的交互机制。

## CPU与内存交互

**CPU**的执行速度远快于内存（RAM）的访问速度。为了缓解这一性能差距，现代计算机在CPU和内存之间引入了**高速缓存（Cache）**。

**缓存工作机制：**

- **缓存命中**：CPU需要的数据在缓存中，直接从缓存读取，速度极快
- **缓存未命中**：数据不在缓存中，从主内存读取并加载到缓存，供后续使用
- **写回策略**：CPU修改数据后，先写入缓存，再择机同步到主内存

这种机制显著提升了性能，但在多线程环境下会引入**可见性问题**：一个线程在自己的CPU缓存中修改了变量，其他线程可能看不到最新值。

## 并发编程的三大特性

- **原子性（Atomicity）**：操作不可分割，要么全部成功，要么全部失败。例如`i++`包含读取、加1、写入三个步骤，不是原子操作
- **可见性（Visibility）**：一个线程修改共享变量后，其他线程能立即看到最新值。由于CPU缓存的存在，可见性无法自动保证
- **有序性（Ordering）**：程序执行顺序与代码顺序一致。编译器和CPU为了优化性能会进行指令重排序，可能改变代码执行顺序

## volatile关键字

`volatile`用于修饰变量，确保多线程环境下的**可见性**和**有序性**，实现轻量级同步。

### 1. 可见性保证

Java内存模型（JMM）规定了`volatile`变量的特殊访问规则：

- **写操作**：线程修改`volatile`变量时，JMM强制将修改立即刷新到主内存
- **读操作**：线程读取`volatile`变量时，JMM强制从主内存中读取最新值，而不是使用缓存中的旧值

**示例：**

```java
public class VolatileVisibility {
    private volatile boolean flag = false;
    
    // 线程1：修改flag
    public void writer() {
        flag = true;  // 立即刷新到主内存
    }
    
    // 线程2：读取flag
    public void reader() {
        if (flag) {  // 从主内存读取最新值
            // 能够立即看到线程1的修改
        }
    }
}
```

### 2. 有序性保证（内存屏障）

`volatile`通过**内存屏障（Memory Barrier）**防止指令重排序：

- **写屏障（Store Barrier）**：
    - 插入在`volatile`写操作**之前**，确保写操作之前的所有普通写操作已刷新到主内存
    - 插入在`volatile`写操作**之后**，防止后续读写操作被重排序到写操作之前
- **读屏障（Load Barrier）**：
    - 插入在`volatile`读操作**之前**，确保能读到最新值
    - 插入在`volatile`读操作**之后**，防止后续读写操作被重排序到读操作之前

**示例：**

```java
public class VolatileOrdering {
    private int a = 0;
    private volatile boolean flag = false;
    
    public void writer() {
        a = 1;           // 普通写
        flag = true;     // volatile写（插入写屏障）
        // flag写入后，a=1一定已经对其他线程可见
    }
    
    public void reader() {
        if (flag) {      // volatile读（插入读屏障）
            // 由于flag为true，此时a一定等于1
            System.out.println(a);  // 输出1
        }
    }
}
```

**重排序规则：**

- `volatile`写之前的操作不会被重排序到写之后
- `volatile`读之后的操作不会被重排序到读之前
- `volatile`写和`volatile`读之间不能重排序

### 3. volatile不能保证原子性

`volatile`只保证可见性和有序性，**不保证原子性**。

**错误示例：**

```java
public class VolatileAtomic {
    private volatile int count = 0;
    
    public void increment() {
        count++;  // 不是原子操作！
        // 实际分为三步：
        // 1. 读取count的值
        // 2. 计算count+1
        // 3. 写入新值
        // 多线程执行时可能丢失更新
    }
}
```

**解决方案：**

- 使用`synchronized`关键字保证原子性
- 使用`AtomicInteger`等原子类
- 使用`Lock`等并发工具

### 4. volatile的典型使用场景

**场景1：状态标志**

```java
private volatile boolean shutdown = false;

public void shutdown() {
    shutdown = true;  // 写线程
}

public void doWork() {
    while (!shutdown) {  // 工作线程
        // 执行任务
    }
}
```

**场景2：双重检查锁定（DCL）单例模式**

```java
public class Singleton {
    private volatile static Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {  // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {  // 第二次检查
                    instance = new Singleton();
                    // volatile防止指令重排序：
                    // 1. 分配内存
                    // 2. 初始化对象
                    // 3. 引用指向内存地址
                }
            }
        }
        return instance;
    }
}
```

## 总结

`volatile`是Java并发编程中的轻量级同步机制：

✅ **保证可见性**：修改立即刷新到主内存，读取总是获取最新值  

✅ **保证有序性**：通过内存屏障防止指令重排序  

❌ **不保证原子性**：复合操作（如`i++`）仍需额外同步

**使用建议：**

- 适用于一写多读的场景（如状态标志）
- 不适用于需要原子性保证的场景（需使用`synchronized`或原子类）
- 性能优于`synchronized`，但功能有限