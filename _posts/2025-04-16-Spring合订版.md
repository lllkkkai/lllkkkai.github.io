---
layout: post
title: Spring合订版
---

## 目录
1. IoC和AOP
2. Spring和Springboot的区别
3. AOP失效场景
4. Spring事务传播机制
5. Bean的生命周期
6. Springboot的自动装配

---

## 1. IoC 和 AOP (一句话总结)

### 1.1 IoC (控制反转)
- **定义**：将对象的创建权从代码交给 Spring 容器。
- **作用**：**解耦**。不用自己 `new`，想要啥找 Spring 要（DI 依赖注入）。
- **比喻**：以前吃饭要自己买菜做饭（手动 new）；现在点外卖（IoC），想要啥只要下个单（@Autowired），外卖小哥（Container）自动送上门。

### 1.2 AOP (面向切面编程)
- **定义**：将通用逻辑（日志、事务、权限）从业务代码中剥离，横向切入。
- **原理**：**动态代理**。
  - **JDK 动态代理**：基于接口（Proxy）。
  - **CGLIB**：基于继承（ASM 字节码修改）。
- **比喻**：像给代码穿了一层“装甲”，核心业务是人，AOP是穿在身上的盔甲（提供防御、辅助），人还是那个人。

---

## 2. Spring 和 SpringBoot 的区别
- **核心区别**：**配置方式不同**。
- **Spring**：**手动挡**。需要配置大量的 XML 或 JavaConfig，繁琐。
- **SpringBoot**：**自动挡**。
  - **约定大于配置**：默认给你配好最常用的。
  - **开箱即用**：内嵌 Tomcat，无需额外部署。
  - **自动装配**：引入依赖通过 `Starter` 自动配置 Bean。

---

## 3. AOP 失效的场景
**核心原因**：**绕过了代理对象**，直接调用了原始对象。

1.  **同类内部调用**：`this.method()`，`this` 指向目标对象而非代理对象。
    - *解决*：注入 `Self` 调用或使用 `AopContext.currentProxy()`。
2.  **方法非 public**：JDK 代理基于接口，只能拦截 public。
3.  **final 方法/类**：CGLIB 基于继承，final 无法被覆盖，代理失效。
4.  **对象未被 Spring 管理**：自己 `new` 出来的对象，Spring 管不着。

---

## 4. Spring 事务传播机制
**定义**：当 A 方法调用 B 方法时，B 是共用 A 的事务，还是另开一个？

### 4.1 核心七种（口诀：3常用 + 4其他）

| 机制 | 行为 | 解释 & 比喻 |
| :--- | :--- | :--- |
| **REQUIRED** (默认) | **共用** 或 新开 | **最常用**。A 有 B 就加入；A 无 B 就新开。 <br> *比喻：搭便车。有车就蹭，没车自己打。* |
| **REQUIRES_NEW** | **独立** (新开) | **完全独立**。不管 A 有没有，B 都新开一个。A 挂了 B 不一定挂。 <br> *比喻：各记各的账。* |
| **NESTED** | **嵌套** (SavePoint) | **子事务**。B 失败回滚到保存点，不影响 A；A 挂了 B 必挂。 <br> *比喻：玩游戏存档。关卡里挂了读档重来，整个游戏退了就全没了。* |
| SUPPORTS | 支持 | 有就用，没就不用事务。 |
| MANDATORY | 强制 | 必须有事务，否则抛异常。 |
| NOT_SUPPORTED | 挂起 | 以非事务运行，有事务先挂起。 |
| NEVER | 禁用 | 必须非事务，有事务就抛异常。 |

### 4.2 面试避坑
- **REQUIRED vs NESTED**：
  - REQUIRED 是**整个**回滚（一荣俱荣）。
  - NESTED 是**局部**回滚（子事务独立回滚，父事务可 catch 继续执行）。
- **失效场景**：不仅要答传播机制，还要结合 **AOP 失效**（如内部调用）一起答。

---


## Bean的生命周期

### 1. 核心流程（面试 4 步法）
Spring Bean 的生命周期非常复杂，面试时建议简化为 **4 个核心阶段**，外加 **扩展点**：

1. **实例化 (Instantiation)**：
   - **定义**：调用构造方法（反射）创建对象。
   - **状态**：此时对象只是个空壳（Raw Object），属性全是 null。
   - **比喻**：盖房子的主体框架，只有墙。

2. **属性赋值 (Populate Properties)**：
   - **定义**：依赖注入（DI），填充 `@Autowired`、`@Value` 等属性。
   - **状态**：对象属性有了，但还没经过“加工”。
   - **比喻**：通水通电、安装家具。

3. **初始化 (Initialization)** —— **最关键（扩展点最多）**：
   - **Aware 接口**：Spring 告诉 Bean 自己叫啥（`BeanNameAware`）、住哪（`BeanFactoryAware`）。
   - **BeanPostProcessor (Before)**：初始化前置处理（常用于修改 Bean 属性）。
   - **Init Method**：执行自定义初始化逻辑（`@PostConstruct` > `InitializingBean` > XML `init-method`）。
   - **BeanPostProcessor (After)**：初始化后置处理（**AOP 动态代理也就是在这里发生的**）。
   - **比喻**：精装修。
     - **Before**：装修队进场前检查。
     - **Init**：刷漆、贴壁纸（正式装修）。
     - **After**：甲醛检测、做保洁（如果发现房子有潜力，就包装成样板间/代理对象）。

4. **销毁 (Destruction)**：
   - **定义**：容器关闭时执行。
   - **方法**：`@PreDestroy` > `DisposableBean` > XML `destroy-method`。
   - **比喻**：房子拆迁。

### 2. 面试必问细节
- **AOP 在哪一步生效？**
  - 在 **初始化后（BeanPostProcessor.postProcessAfterInitialization）**。
  - 如果 Bean 需要被代理（如配置了事务、切面），Spring 会在这里生成代理对象替换原始对象。
- **循环依赖发生在哪个阶段？**
  - 发生在 **实例化之后、属性赋值之前**。
  - Spring 利用三级缓存，将“实例化但未属性赋值”的半成品 Bean 提前暴露出来，供其他 Bean 引用。

---

## Springboot的自动装配

### 1. 是什么？
- **定义**：Spring Boot 根据你引入的 Jar 包依赖，**自动**配置并注册常见的 Spring Bean，无需手动编写繁琐的 XML 或 Java Config。
- **核心思想**：**约定大于配置** (Convention over Configuration)。

### 2. 实现原理（核心三步）
自动装配的“魔法”入口是主启动类上的 `@SpringBootApplication` 注解，它复合了 `@EnableAutoConfiguration`。

#### 第一步：启动加载器 (`@Import`)
- `@EnableAutoConfiguration` 内部使用 `@Import(AutoConfigurationImportSelector.class)`。
- 这个 Selector 负责去加载配置类。

#### 第二步：扫描配置 (`spring.factories`)
- Spring Boot 会扫描所有 Jar 包下的 `META-INF/spring.factories` 文件（Spring Boot 2.7+ 后改为 `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`）。
- 这些文件里列出了所有可能的自动配置类（如 `RedisAutoConfiguration`, `JdbcTemplateAutoConfiguration` 等）。

#### 第三步：按需加载 (`@Conditional`)
- 虽然扫描到了上百个配置类，但**不会全部加载**，而是通过 **`@Conditional`** 系列注解进行过滤：
  - **`@ConditionalOnClass`**：只有 Classpath 下存在某个类时才生效（例如：只有引入了 `redis-jedis` 包，`RedisAutoConfiguration` 才生效）。
  - **`@ConditionalOnMissingBean`**：只有用户没有自己定义某个 Bean 时，Spring Boot 才帮忙配置（例如：你没写 `RedisTemplate`，它才送你一个默认的；你写了，它就退避三舍）。

### 3. 比喻：酒店服务
- **传统 Spring**：像是**租房**。
  - 想要床？自己买。想要网？自己拉。什么都要自己 `new` 或 `config`。
- **Spring Boot**：像是**住五星级酒店**。
  - **自动装配**：推门进去，床、电视、WIFI（常用 Bean）都已经装好了。
  - **按需加载**：
    - 酒店看你带了牙刷（用户自定义 Bean），它就不给你提供一次性牙刷（`ConditionalOnMissingBean`）。
    - 酒店看你没带拖鞋，它就自动放一双在门口。

---
