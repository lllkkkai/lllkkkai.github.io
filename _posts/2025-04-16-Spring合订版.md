---
layout: post
title: Spring合订版
---

## 目录
1. IoC和AOP
2. Spring和Springboot的区别
3. AOP失效场景
4. Spring事务传播机制
5. Bean的生命周期
6. Springboot的自动装配

---

## 1. IoC 和 AOP (一句话总结)

### 1.1 IoC (控制反转)
- **定义**：将对象的创建权从代码交给 Spring 容器。
- **作用**：**解耦**。不用自己 `new`，想要啥找 Spring 要（DI 依赖注入）。
- **比喻**：以前吃饭要自己买菜做饭（手动 new）；现在点外卖（IoC），想要啥只要下个单（@Autowired），外卖小哥（Container）自动送上门。

### 1.2 AOP (面向切面编程)
- **定义**：将通用逻辑（日志、事务、权限）从业务代码中剥离，横向切入。
- **原理**：**动态代理**。
  - **JDK 动态代理**：基于接口（Proxy）。
  - **CGLIB**：基于继承（ASM 字节码修改）。
- **比喻**：像给代码穿了一层“装甲”，核心业务是人，AOP是穿在身上的盔甲（提供防御、辅助），人还是那个人。

### 1.3 常用 AOP 注解
- **@Aspect**：**身份牌**。标记这个类是一个“切面”（Aspect）。
- **@Pointcut**：**定位器**。定义“切哪里”（包名、类名、方法名）。
- **通知（Advice）注解**：
  - **@Before**：**前置**。方法执行**前**干活。
  - **@After**：**最终**（Finally）。方法执行**后**干活（不管成不成功，类似 `finally` 块）。
  - **@Around**：**环绕**（最强）。包围目标方法，能决定是否执行目标方法，还能修改返回值。
  - **@AfterReturning**：**后置返回**。方法**成功返回**后干活（可以拿到返回值）。
  - **@AfterThrowing**：**异常**。方法**抛异常**后干活（可以拿到异常信息）。

> **⚠️ 面试高频：执行顺序 (Spring 5.2.7+)**
> **正常情况**：`@Around` (前) -> `@Before` -> 目标方法 -> `@AfterReturning` -> `@After` -> `@Around` (后)
> **异常情况**：`@Around` (前) -> `@Before` -> 目标方法 -> `@AfterThrowing` -> `@After`

---

## 2. Spring 和 SpringBoot 的区别
- **核心区别**：**配置方式不同**。
- **Spring**：**手动挡**。需要配置大量的 XML 或 JavaConfig，繁琐。
- **SpringBoot**：**自动挡**。
  - **约定大于配置**：默认给你配好最常用的。
  - **开箱即用**：内嵌 Tomcat，无需额外部署。
  - **自动装配**：引入依赖通过 `Starter` 自动配置 Bean。

---

## 3. AOP 失效的场景
**核心原因**：**绕过了代理对象**，直接调用了原始对象。

1.  **同类内部调用**：`this.method()`，`this` 指向目标对象而非代理对象。
    - *解决*：注入 `Self` 调用或使用 `AopContext.currentProxy()`。
2.  **方法非 public**：JDK 代理基于接口，只能拦截 public。
3.  **final 方法/类**：CGLIB 基于继承，final 无法被覆盖，代理失效。
4.  **对象未被 Spring 管理**：自己 `new` 出来的对象，Spring 管不着。

---

## 4. Spring 事务传播机制
**定义**：当 A 方法调用 B 方法时，B 是共用 A 的事务，还是另开一个？

### 4.1 核心七种（口诀：3常用 + 4其他）

| 机制 | 行为 | 解释 & 比喻 |
| :--- | :--- | :--- |
| **REQUIRED** (默认) | **共用** 或 新开 | **最常用**。A 有 B 就加入；A 无 B 就新开。 <br> *比喻：搭便车。有车就蹭，没车自己打。* |
| **REQUIRES_NEW** | **独立** (新开) | **完全独立**。不管 A 有没有，B 都新开一个。A 挂了 B 不一定挂。 <br> *比喻：各记各的账。* |
| **NESTED** | **嵌套** (SavePoint) | **子事务**。B 失败回滚到保存点，不影响 A；A 挂了 B 必挂。 <br> *比喻：玩游戏存档。关卡里挂了读档重来，整个游戏退了就全没了。* |
| SUPPORTS | 支持 | 有就用，没就不用事务。 |
| MANDATORY | 强制 | 必须有事务，否则抛异常。 |
| NOT_SUPPORTED | 挂起 | 以非事务运行，有事务先挂起。 |
| NEVER | 禁用 | 必须非事务，有事务就抛异常。 |

### 4.2 面试避坑
- **REQUIRED vs NESTED**：
  - REQUIRED 是**整个**回滚（一荣俱荣）。
  - NESTED 是**局部**回滚（子事务独立回滚，父事务可 catch 继续执行）。
- **失效场景**：不仅要答传播机制，还要结合 **AOP 失效**（如内部调用）一起答。

---


## Bean的生命周期

### 1. 核心流程（面试 4 步法）
Spring Bean 的生命周期非常复杂，面试时建议简化为 **4 个核心阶段**，外加 **扩展点**：

1. **实例化 (Instantiation)**：
   - **定义**：调用构造方法（反射）创建对象。
   - **状态**：此时对象只是个空壳（Raw Object），属性全是 null。
   - **比喻**：盖房子的主体框架，只有墙。

2. **属性赋值 (Populate Properties)**：
   - **定义**：依赖注入（DI），填充 `@Autowired`、`@Value` 等属性。
   - **状态**：对象属性有了，但还没经过“加工”。
   - **比喻**：通水通电、安装家具。

3. **初始化 (Initialization)** —— **最关键（扩展点最多）**：
   - **Aware 接口**：Spring 告诉 Bean 自己叫啥（`BeanNameAware`）、住哪（`BeanFactoryAware`）。
   - **BeanPostProcessor (Before)**：初始化前置处理（常用于修改 Bean 属性）。
   - **Init Method**：执行自定义初始化逻辑（`@PostConstruct` > `InitializingBean` > XML `init-method`）。
   - **BeanPostProcessor (After)**：初始化后置处理（**AOP 动态代理也就是在这里发生的**）。
   - **比喻**：精装修。
     - **Before**：装修队进场前检查。
     - **Init**：刷漆、贴壁纸（正式装修）。
     - **After**：甲醛检测、做保洁（如果发现房子有潜力，就包装成样板间/代理对象）。

4. **销毁 (Destruction)**：
   - **定义**：容器关闭时执行。
   - **方法**：`@PreDestroy` > `DisposableBean` > XML `destroy-method`。
   - **比喻**：房子拆迁。

### 2. 面试必问细节
- **AOP 在哪一步生效？**
  - 在 **初始化后（BeanPostProcessor.postProcessAfterInitialization）**。
  - 如果 Bean 需要被代理（如配置了事务、切面），Spring 会在这里生成代理对象替换原始对象。
- **循环依赖发生在哪个阶段？**
  - 发生在 **实例化之后、属性赋值之前**。
  - Spring 利用三级缓存，将“实例化但未属性赋值”的半成品 Bean 提前暴露出来，供其他 Bean 引用。

---

## Springboot的自动装配

### 1. 通俗理解 (What)
**以前 (SSM)**：你想吃火锅（开发 Web 应用），需自己买锅、买底料、洗菜、切肉（写 XML、配 DispatcherServlet、ViewResolver）。
**现在 (SpringBoot)**：你只需买张**火锅券**（引入 `spring-boot-starter-web` 依赖），进店直接吃（Spring Boot 自动给你配好锅底和菜）。

**一句话总结**：**你已引入的 Jar 包** + **默认配置** = **自动生成的 Bean**。
> *无需自己写 `<bean id="..." class="...">` 或 `@Configuration`，Spring Boot 猜到你想用，就直接给你配好了。*

### 2. 它是怎么做到的？ (How)
**核心原理**：**SPI 机制** + **条件注解**。
启动类上的 **`@SpringBootApplication`** 是个组合注解，核心看 **`@EnableAutoConfiguration`**：

1.  **找（Load）**：
    - 利用 **`@Import`** 和 Java 的 SPI 机制，去所有 Jar 包的 `META-INF/spring.factories` (或 `.../AutoConfiguration.imports`) 找所有的 "自动配置类"。
    - *潜台词*："先把所有能干活的工人都叫过来排队。" (找到 100+ 个 AutoConfiguration 类，如 `RedisAutoConfiguration`, `WebMvcAutoConfiguration`)

2.  **筛（Filter）**：
    - 通过 **`@Conditional`** 系列注解进行筛选。
    - *潜台词*："只有手里拿了铲子（有相关依赖）的才留下炒菜。"
    - 例如 `RedisAutoConfiguration` 上写了 `@ConditionalOnClass(RedisOperations.class)`。
    - 如果你 `pom.xml` 里没引 Redis 的包，Classpath 下没这个类，这个配置就不生效 (省内存，不加载)。

3.  **配（Configure）**：
    - 筛选剩下的配置类生效，往容器里注册 Bean。
    - 结合 **`@ConditionalOnMissingBean`**：只有当你自己没配的时候，Spring Boot 才给你配；你配了就听你的。

### 3. 三个关键面试点
1.  **`@EnableAutoConfiguration`**：总开关。
2.  **`spring.factories`**：配置清单（在这个文件里列出了所有能自动装配的类）。
3.  **`@Conditional`**：核心过滤器（OnClass, OnBean, OnMissingBean）。

---
