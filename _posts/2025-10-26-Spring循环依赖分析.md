---
layout: post
title: Spring循环依赖分析
---


<!--more-->

## 什么是循环依赖

循环依赖是指两个或多个Bean之间相互依赖，形成了一个闭环。最常见的情况是：

- **A依赖B，B依赖A**（双向依赖）
- **A依赖B，B依赖C，C依赖A**（多向循环依赖）

举个简单的例子：

```java
@Service
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Service
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
}
```

在这个例子中，ServiceA需要注入ServiceB，而ServiceB又需要注入ServiceA，这就形成了循环依赖。

## Spring是怎么解决的？

Spring通过**三级缓存**机制解决了**单例Bean**的**setter注入**方式的循环依赖问题。

### 三级缓存机制

Spring容器内部维护了三个Map缓存：

**1. 一级缓存（singletonObjects）**

- 存放完全初始化好的单例Bean
- 这是最终可用的Bean实例

**2. 二级缓存（earlySingletonObjects）**

- 存放早期的Bean引用（已实例化但未完成属性注入和初始化）
- 用于解决循环依赖

**3. 三级缓存（singletonFactories）**

- 存放Bean工厂对象
- 用于生成早期Bean引用

### 解决流程

以ServiceA和ServiceB的循环依赖为例：

1. **创建ServiceA**
    - Spring实例化ServiceA（调用构造方法）
    - 将ServiceA的工厂对象放入三级缓存
    - 开始填充ServiceA的属性
2. **发现需要注入ServiceB**
    - 尝试获取ServiceB，发现容器中没有
    - 开始创建ServiceB
3. **创建ServiceB**
    - Spring实例化ServiceB
    - 将ServiceB的工厂对象放入三级缓存
    - 开始填充ServiceB的属性
4. **发现需要注入ServiceA**
    - 尝试获取ServiceA
    - 从三级缓存中找到ServiceA的工厂对象
    - 通过工厂获取ServiceA的早期引用（此时ServiceA还未完全初始化）
    - 将这个早期引用放入二级缓存，并从三级缓存中移除
    - 将早期引用注入到ServiceB中
5. **完成ServiceB的创建**
    - ServiceB完成属性填充和初始化
    - 将ServiceB放入一级缓存
    - 返回ServiceB实例
6. **完成ServiceA的创建**
    - 将ServiceB注入到ServiceA中
    - ServiceA完成属性填充和初始化
    - 将ServiceA放入一级缓存

### 为什么需要三级缓存？

你可能会问：**为什么需要三级缓存？二级不够吗？**

三级缓存的主要作用是**支持AOP代理**。如果Bean需要被代理（如使用了@Transactional、@Async等注解），那么注入到其他Bean的应该是代理对象，而不是原始对象。三级缓存中的工厂对象可以在需要时生成代理对象，确保注入的是正确的对象。

## Spring没有解决什么问题？

虽然Spring的三级缓存机制很强大，但**并不是所有的循环依赖都能解决**。以下几种情况Spring无法处理：

### 1. 构造器注入的循环依赖

```java
@Service
public class ServiceA {
    private ServiceB serviceB;
    
    @Autowired
    public ServiceA(ServiceB serviceB) {
        this.serviceB = serviceB;
    }
}

@Service
public class ServiceB {
    private ServiceA serviceA;
    
    @Autowired
    public ServiceB(ServiceA serviceA) {
        this.serviceA = serviceA;
    }
}
```

**为什么无法解决？**

因为构造器注入要求在实例化对象时就必须提供依赖的Bean。但此时依赖的Bean还没创建，形成了死锁。Spring会抛出`BeanCurrentlyInCreationException`异常。

### 2. prototype作用域的循环依赖

```java
@Service
@Scope("prototype")
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Service
@Scope("prototype")
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
}
```

**为什么无法解决？**

prototype作用域的Bean每次获取都会创建新实例，Spring不会缓存prototype Bean，因此三级缓存机制无法使用。

### 3. 多例Bean之间的循环依赖

与prototype类似，多例Bean不会被缓存，因此无法通过三级缓存解决循环依赖。

### 解决建议

遇到Spring无法解决的循环依赖时，可以采用以下方案：

1. **使用setter注入代替构造器注入**
2. **使用@Lazy注解延迟加载**
    
    ```java
    @Service
    public class ServiceA {
        private ServiceB serviceB;
        
        @Autowired
        public ServiceA(@Lazy ServiceB serviceB) {
            this.serviceB = serviceB;
        }
    }
    ```
    
3. **重新设计代码结构，避免循环依赖**
    - 考虑是否可以提取公共逻辑到第三个类
    - 考虑是否可以使用事件驱动的方式解耦

## 总结

- Spring通过三级缓存机制可以解决**单例Bean**的**setter注入**方式的循环依赖
- 构造器注入和prototype作用域的循环依赖无法解决
- 实际开发中应尽量避免循环依赖，优化代码设计