---
layout: post
category: Mysql
---

# Mysql有哪些日志文件
1. 错误日志：
2. 通用查询日志：
3. binlog：两个使用场景数据库恢复和主从复制
4. undo/redo log
5. 中继日志 relay log
6. 慢查询日志：记录所有执行时间超时的查询sql，默认是10s

## binlog
**什么时候产生**：

事务提交的时候，一次性将事务中的sql语句（一个事物可能对应多个sql语句）按照一定的格式记录到binlog中。

这里与redo log很明显的差异就是redo log并不一定是在事务提交的时候刷新到磁盘，redo log是在事务开始之后就开始逐步写入磁盘。

因此对于事务的提交，即便是较大的事务，提交（commit）都是很快的，但是在开启了bin_log的情况下，对于较大事务的提交，可能会变得比较慢一些。

这是因为binlog是在事务提交的时候一次性写入的造成的，这些可以通过测试验证。

**什么时候释放**：

binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。

**跟redo log对比**

二进制日志的作用之一是还原数据库的，这与redo log很类似，很多人混淆过，但是两者有本质的不同

- 作用不同：redo log是保证事务的持久性的，是事务层面的，binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的），虽然都有还原的意思，但是其保护数据的层次是不一样的。

- 内容不同：redo log是物理日志，是数据页面的修改之后的物理记录，binlog是逻辑日志，可以简单认为记录的就是sql语句

另外，两者日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的。

恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog

关于事务提交时，redo log和binlog的写入顺序，为了保证主从复制时候的主从一致（当然也包括使用binlog进行基于时间点还原的情况），是要严格一致的，MySQL通过两阶段提交过程来完成事务的一致性的，也即redo log和binlog的一致性的，理论上是先写redo log，再写binlog，两个日志都提交成功（刷入磁盘），事务才算真正的完成。

## 慢查询日志
慢日志记录执行时间过长和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句


### 1. MySQL 事务的实现原理和 Binlog 的关系
#### 事务是啥？
- **事务**：
  - 一组操作（比如转账：A 减 100，B 加 100），要么全成功，要么全失败，保证数据一致性（ACID）。
- **比喻**：
  - 像饭店点菜，炒菜、上菜、结账要一起完成，炒了菜不上桌得退回。

#### 事务的实现原理（以 InnoDB 为例）
InnoDB 是 MySQL 默认引擎，事务靠 **日志** 和 **锁** 实现：

##### (1) 日志机制
- **Redo Log（重做日志）**：
  - 记录“做了啥”（物理变化，比如“改第 5 页第 3 行值为 100”）。
  - 保证持久性（D）：宕机后恢复数据。
- **Undo Log（回滚日志）**：
  - 记录“改前啥样”（逻辑变化，比如“原来是 50”）。
  - 保证原子性（A）：失败时回滚。
- **比喻**：
  - Redo 是“炒菜步骤”，Undo 是“退菜记录”，保证菜上桌或退干净。

##### (2) 锁机制
- **行锁/表锁**：
  - 控制并发，隔离性（I）：事务间不干扰。
- **MVCC（多版本并发控制）**：
  - 用 Undo Log 存旧版本，读不堵写，一致性（C）。
- **比喻**：
  - 锁是“厨房门”，MVCC 是“多份菜单”，保证大家点菜不乱。

##### (3) 事务提交流程
- 客户端跑：
  ```sql
  START TRANSACTION;
  UPDATE users SET balance = balance - 100 WHERE id = 1;
  UPDATE users SET balance = balance + 100 WHERE id = 2;
  COMMIT;
  ```
- **内部**：
  1. **写 Undo Log**：记下改前数据（id=1: 200, id=2: 50）。
  2. **改内存**：更新缓冲池（balance: 100, 150）。
  3. **写 Redo Log**：记下改后数据。
  4. **COMMIT**：
     - Redo Log 刷盘（fsync），事务完成。
     - 内存数据稍后刷表（异步）。
- **比喻**：
  - 先记退菜单（Undo），炒菜（内存），记步骤（Redo），上桌（COMMIT）。

#### Binlog 登场
- **Binlog（二进制日志）**：
  - MySQL Server 层的日志，记录逻辑操作（`UPDATE users SET...`），用于复制和恢复。
- **和事务的关系**：
  - 事务提交时，Binlog 记录整个事务的操作。
  - **时机**：
    - 默认异步：Redo Log 刷盘后，Binlog 再写。
    - 半同步/同步：Binlog 和 Redo 一起刷。
- **比喻**：
  - Redo 是“炒菜步骤”（引擎层），Binlog 是“菜单备份”（Server 层），给助手（从库）抄。

#### Binlog 和事务的协作
- **两阶段提交（2PC）**：
  1. **Prepare 阶段**：
     - 事务改数据，写 Undo 和 Redo，Redo 刷盘。
  2. **Commit 阶段**：
     - 写 Binlog，标记事务提交。
     - Binlog 刷盘，事务算完成。
- **为啥 2PC**：
  - 保证 Redo 和 Binlog 一致，宕机恢复时不丢操作。
- **比喻**：
  - 大厨炒完菜（Redo），记菜单（Binlog），两步确认菜上桌。

#### 关系总结
- **事务靠 Redo/Undo 实现**：
  - Redo 保持久，Undo 保回滚，锁和 MVCC 保隔离一致。
- **Binlog 是外援**：
  - 记录事务结果，供复制和恢复，和事务提交绑定。
- **比喻**：
  - 事务是大厨炒菜，Binlog 是助手抄菜单，炒完菜菜单得跟上。

---

### 2. 事务实现依赖主从一致性吗？
#### 答案：不依赖
- **事务实现**：
  - 只在主库（Master）本地完成，靠 InnoDB 的日志和锁。
  - 从库（Slave）不参与事务执行。
- **比喻**：
  - 大厨炒菜（事务）在自己厨房完成，助手（从库）只抄菜单，不炒。

#### 主从复制和事务的关系
- **异步复制**：
  - 主库提交事务，写 Binlog，返回客户端。
  - 从库 IO 线程拉 Binlog，SQL 线程执行，慢半拍。
  - **不影响事务**：主库不管从库跟没跟上。
- **半同步复制**：
  - 主库提交等至少一个从库收到 Binlog。
  - **影响提交时间**：但事务逻辑还是主库完成。
- **比喻**：
  - 大厨炒完菜（事务），菜单给助手抄，异步是大厨不管助手，半同步是等助手说“收到”。

#### 分布式一致性？
- **主从不是分布式事务**：
  - 分布式事务（比如 XA）涉及多节点共同提交，主从不是。
  - 主从复制是“单点事务 + 复制”，从库只读不参与。
- **一致性问题**：
  - 从库延迟（读不到最新数据）是复制问题，不是事务问题。
- **比喻**：
  - 大厨炒菜是一人决定，助手抄慢了不影响菜做好。

#### 事务独立性
- **主库单机完成**：
  - Redo/Undo/Binlog 都在主库，事务 ACID 不靠从库。
- **从库是影子**：
  - 从库照抄 Binlog，执行出错（比如跳过）不影响主库事务。
- **比喻**：
  - 大厨炒菜成功，助手抄错了，大厨的菜还是好的。

---

### 3. 举个例子
- **主库**：
  ```sql
  START TRANSACTION;
  UPDATE users SET balance = 100 WHERE id = 1;
  COMMIT;
  ```
  - Redo: “改 id=1 balance=100”。
  - Binlog: “UPDATE users SET balance=100 WHERE id=1”。
  - 提交：Redo 刷盘，Binlog 写完。
- **从库**：
  - IO 线程拉 Binlog，SQL 线程执行，慢 1 秒。
- **宕机**：
  - 主库恢复靠 Redo，事务完整。
  - 从库不影响主库提交。

---

### 4. 通俗总结
- **事务原理**：
  - Redo 保持久，Undo 保回滚，锁和 MVCC 保隔离，Binlog 记结果。
- **Binlog 关系**：
  - 事务提交时写 Binlog，像菜单备份，和 Redo 两步确认。
- **主从一致性**：
  - 事务不靠从库，主库本地搞定，复制是额外福利。
- **比喻**：
  - 大厨炒菜（事务）靠自己，菜单（Binlog）抄给助手（从库），助手慢不影响菜。

---

### 5. 检查理解
- Redo 和 Binlog 咋分工？
- 事务咋不靠从库？
- 主从延迟咋影响读？


# MySQL宕机恢复中的日志作用

## 1. Redo Log（重做日志）的作用

### 场景一：事务已提交，数据未刷盘时宕机
```plaintext
操作流程：
1. 事务执行：UPDATE account SET balance = 900 WHERE id = 1
2. 写入Redo Log并标记为已提交
3. 内存中修改数据页（balance = 900）
4. 宕机（数据页未刷入磁盘）
```

**恢复过程**：
- 服务器重启时，InnoDB扫描Redo Log
- 发现已提交事务的Redo Log记录
- 根据Redo Log重放操作，将balance改为900
- 保证了已提交事务的持久性

## 2. Undo Log（回滚日志）的作用

### 场景二：事务执行中宕机
```plaintext
操作流程：
1. 开启事务：START TRANSACTION
2. 记录原值到Undo Log（balance = 1000）
3. 执行更新：UPDATE account SET balance = 900 WHERE id = 1
4. 宕机（事务未提交）
```

**恢复过程**：
- 服务器重启时，检查未完成的事务
- 发现未提交的事务
- 根据Undo Log进行回滚，将balance恢复为1000
- 保证了事务的原子性

## 3. Binlog（二进制日志）的作用

### 场景三：需要数据恢复
```plaintext
操作流程：
1. 每天0点全量备份数据库
2. 记录当天的所有Binlog
3. 下午3点数据库宕机且数据文件损坏
```

**恢复过程**：
```sql
-- 1. 先恢复最近的全量备份
mysql -u root -p < backup_20240424_000000.sql

-- 2. 使用Binlog恢复增量数据
mysqlbinlog mysql-bin.000001 --start-datetime="2024-04-24 00:00:00" \
                             --stop-datetime="2024-04-24 15:00:00" | mysql -u root -p
```

## 4. 三种日志协同工作

### 场景四：事务提交过程中宕机
```plaintext
操作流程：
1. 事务执行更新操作
2. 写入Undo Log
3. 写入Redo Log（prepare状态）
4. 写入Binlog
5. 宕机
```

**恢复规则**：
- 如果Binlog完整写入：提交事务
- 如果Binlog未完整写入：回滚事务

### 恢复顺序：
1. **检查点扫描**：
   - 从最近的检查点开始扫描Redo Log
   - 找出所有未完成的事务

2. **事务状态判断**：
   - 对每个未完成事务，检查Binlog写入状态
   - 决定提交或回滚

3. **数据恢复**：
   - 使用Redo Log恢复已提交的事务
   - 使用Undo Log回滚未完成的事务

## 5. 最佳实践

### 配置建议
```ini
# my.cnf配置
[mysqld]
# Redo Log配置
innodb_log_files_in_group = 2
innodb_log_file_size = 1G

# Binlog配置
sync_binlog = 1
innodb_flush_log_at_trx_commit = 1

# Undo Log配置
innodb_undo_tablespaces = 2
```

### 监控建议
1. 监控日志文件大小和使用情况
2. 监控日志写入延迟
3. 定期测试恢复流程

## 总结

- **Redo Log**：确保已提交事务的数据不丢失
- **Undo Log**：确保未提交事务能够回滚
- **Binlog**：用于时间点恢复和主从复制

这三种日志互相配合，共同确保了MySQL的数据一致性和可靠性。在实际运维中，建议定期进行恢复演练，确保在发生宕机时能够快速恢复数据。