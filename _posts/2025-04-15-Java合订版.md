---
layout: post
title: Java合订版
---
## 基础题
锁的粒度
1. 对象锁
2. 类锁
3. 代码块锁

可重入
并发容器


## IO
- BIO 是阻塞 IO，像村里邮差每户（连接）等信（读），每户一线程，高并发要万线程，内存爆，适合小网站。代码用 ServerSocket，read 卡线程。
- NIO 是非阻塞 IO，邮差用告示板（Selector）看多户（Channel），单线程管万连接，配 Buffer 批量读，高效省资源，适合 Web 服务器。代码用 ServerSocketChannel、Selector。

- select 是 Linux 多路复用，村长（内核）轮询查户（FD）有无信，O(n) 慢，限 1024 FD，适合百连接。
- epoll 优化 select，村长用电话（事件表）等信，O(1) 快，支持百万 FD，Redis、Nginx 用它，抗高并发。

总结：BIO 简单低并发，NIO 高效高并发；select 轮询低效，epoll 事件驱动强。如果想深挖场景，我可以展开！”
## GC
怎么判断对象是否可以回收？
- GC Root（）开始寻找所有可达对象
- 分代算法区分新生代（回收频繁）、老年代（回收慢），老年代引用新生代的对象不会被回收，全扫老年代又太慢，
- 卡表作用：把老年代分成小块（卡页，通常 512 字节）
- 卡表是数组，每位/字节对应 1 卡页。

内存泄漏是怎么发生的？

## 排查线上问题


## 类加载过程
