---
layout: post
title: "分布式事务"
date: 2026-01-04
categories: [Distributed Systems]
---

# 分布式事务

了解分布式事务，首先要了解什么是分布式，前置了解

- CAP（Consistency、Availability、Partition tolerance）
- BASE（Basic Available、Soft State、Eventual consistency）

## 一、分布式事务的本质理解

### 1.1 什么是分布式事务

- 定义：跨越多个网络节点的事务操作，需要保证多个服务/数据库的数据一致性
- 典型场景举例
    - 电商下单：订单服务扣库存 + 支付服务扣款 + 积分服务加积分
    - 转账场景：A 账户扣款 + B 账户加款
    - 微服务拆分后的跨服务操作

### 1.2 为什么会有分布式事务问题

- 单体应用的本地事务（ACID）无法跨越网络边界
- 微服务架构下，数据库按服务拆分，无法使用传统事务
- 网络不可靠：延迟、丢包、超时、分区

## 二、理论基础（面试高频考点）

### 2.1 CAP 定理

- **C**onsistency（一致性）：所有节点看到的数据是一致的
- **A**vailability（可用性）：每个请求都能得到响应
- **P**artition tolerance（分区容错性）：网络分区时系统仍能工作
- **核心结论**：三者只能取其二，分布式系统必须容忍分区（P），因此只能在 C 和 A 之间权衡

### 2.2 BASE 理论

- **BA**sically Available（基本可用）：允许损失部分可用性
- **S**oft state（软状态）：允许中间状态存在
- **E**ventually consistent（最终一致性）：经过一段时间后达到一致
- **与 ACID 的关系**：BASE 是对 CAP 中 AP 的延伸，牺牲强一致性换取可用性

## 三、主流解决方案详解

### 3.1 两阶段提交（2PC）

**核心思想**：协调者统一协调，分两个阶段完成事务

- **阶段一（准备阶段）**：协调者询问所有参与者是否可以提交，参与者执行事务但不提交
- **阶段二（提交阶段）**：如果所有参与者都同意，协调者通知提交；否则回滚

**优点**：

- 实现了强一致性
- 逻辑简单清晰

**缺点**：

- 同步阻塞：参与者等待协调者指令期间资源被锁定
- 单点故障：协调者挂了整个系统不可用
- 数据不一致：阶段二网络分区可能导致部分提交部分回滚
- 性能差：RT 长，吞吐量低

### 3.2 三阶段提交（3PC）

**改进点**：增加超时机制和 CanCommit 阶段

- **阶段一（CanCommit）**：询问是否可以执行事务
- **阶段二（PreCommit）**：执行事务但不提交
- **阶段三（DoCommit）**：提交或回滚

**相比 2PC 的优势**：

- 降低阻塞范围，引入超时机制
- 但仍然无法完全解决数据一致性问题

### 3.3 TCC（Try-Confirm-Cancel）

**核心思想**：业务层面的两阶段提交，将事务拆成三个操作

- **Try**：资源检查和预留
- **Confirm**：执行业务操作，使用 Try 预留的资源
- **Cancel**：释放 Try 预留的资源

**实现要点**：

- 需要业务代码实现三个接口
- 要保证幂等性（重复调用结果一致）
- 需要处理空回滚、悬挂等异常场景

**优点**：

- 不依赖数据库锁，性能较好
- 最终一致性保证

**缺点**：

- 业务侵入性强，开发成本高
- 需要处理各种边界场景

### 3.4 本地消息表

**核心思想**：利用本地事务 + 消息队列实现最终一致性

**实现流程**：

1. 本地事务中，业务操作 + 插入消息表（同一个数据库事务）
2. 定时任务扫描消息表，发送消息到 MQ
3. 消费者消费消息，执行下游业务
4. 消费成功后，更新消息状态或删除消息

**优点**：

- 实现简单，利用数据库本地事务保证消息一定会发送
- 最终一致性保证

**缺点**：

- 业务表和消息表耦合
- 需要额外的定时任务
- 消息表可能成为性能瓶颈

### 3.5 可靠消息最终一致性（基于 MQ）

**核心思想**：使用消息队列的事务消息功能（如 RocketMQ）

**RocketMQ 事务消息流程**：

1. 发送半消息（Half Message）到 MQ，对消费者不可见
2. 执行本地事务
3. 根据本地事务结果，提交或回滚半消息
4. MQ 定期回查本地事务状态（防止提交/回滚消息丢失）
5. 消费者消费消息，执行下游操作（需保证幂等）

**优点**：

- 业务侵入小
- 性能好，异步处理
- MQ 保证消息可靠性

**缺点**：

- 只能保证最终一致性，不是强一致
- 依赖 MQ 的可靠性
- 需要实现事务状态回查接口

### 3.6 Saga 模式

**核心思想**：长事务拆分为多个本地短事务，每个事务都有对应的补偿操作

**两种实现方式**：

- **事件编排**：每个服务监听事件，完成后发布新事件，去中心化
- **命令协调**：协调器统一调度，类似工作流

**执行流程**：

- 正向：T1 -> T2 -> T3 -> ... -> Tn
- 回滚：Tn 失败 -> Cn-1 -> Cn-2 -> ... -> C1

**优点**：

- 适合长事务场景
- 不需要锁资源，性能好

**缺点**：

- 缺乏隔离性，可能读到中间状态
- 补偿逻辑复杂

### 3.7 Seata 分布式事务框架

**支持的模式**：

- **AT 模式**：自动补偿，无业务侵入（类似 2PC，但基于全局锁优化）
- **TCC 模式**：业务侵入，性能更好
- **Saga 模式**：长事务场景
- **XA 模式**：标准 XA 协议，强一致

**AT 模式核心机制**：

- 一阶段：本地事务提交，注册分支到 TC，记录 undo_log
- 二阶段：提交时删除 undo_log；回滚时根据 undo_log 反向补偿

## 四、实际应用与选型（高频面试题）

### 4.1 如何选择分布式事务方案

| 场景 | 推荐方案 | 理由 |
| --- | --- | --- |
| 强一致性要求（如金融核心） | 2PC/XA 或避免分布式事务 | 保证 ACID |
| 一般业务场景 | 本地消息表 / 可靠消息 | 平衡性能与一致性 |
| 高性能要求 | TCC / Saga | 无锁，异步 |
| 快速开发 | Seata AT 模式 | 低侵入，自动补偿 |
| 长流程业务 | Saga | 天然支持长事务 |

### 4.2 ~~我在项目中的实践（根据自己经历填充）~~

**~~场景**：~~

- ~~描述你遇到的具体业务场景~~
- ~~为什么会有分布式事务问题~~

**~~方案选择**：~~

- ~~考虑了哪些方案~~
- ~~最终选择了什么方案，为什么~~

**~~实现细节**：~~

- ~~关键代码逻辑~~
- ~~遇到的坑和解决方案~~

**~~效果**：~~

- ~~性能指标~~
- ~~一致性保证~~

## 五、常见面试追问与深挖

### 5.1 如何保证幂等性

- **全局唯一 ID**：业务单号、UUID、雪花算法
- **数据库唯一索引**：防止重复插入
- **分布式锁**：Redis SETNX、ZooKeeper
- **状态机**：只允许特定状态流转
- **Token 机制**：先获取 Token，提交时校验并删除

### 5.2 如何处理超时和重试

- **超时设置**：合理的超时时间，避免过长阻塞
- **重试策略**：指数退避、最大重试次数
- **补偿机制**：定时任务扫描异常数据，人工介入

### 5.3 分布式事务的性能优化

- **尽量避免**：能否通过业务重构避免分布式事务
- **异步化**：能异步的尽量异步，降低 RT
- **最终一致性**：放宽一致性要求，提升性能
- **分段提交**：减少锁持有时间

### 5.4 如果下游服务一直失败怎么办

- **设置最大重试次数**：避免无限重试
- **死信队列**：失败消息进入死信队列
- **人工介入**：告警 + 后台管理界面手动处理
- **降级策略**：记录失败，后续补偿

### 5.5 本地消息表 vs RocketMQ 事务消息

- **本地消息表**：
    - 优点：不依赖特定 MQ，实现简单
    - 缺点：需要定时任务，消息表可能是瓶颈
- **RocketMQ 事务消息**：
    - 优点：MQ 帮你做状态管理和回查，性能更好
    - 缺点：依赖 RocketMQ，需要实现回查接口

## 六、总结

### 回答思路

1. **定义和场景**：先说清楚什么是分布式事务，为什么会有这个问题
2. **理论基础**：简述 CAP 和 BASE，体现理论深度
3. **方案对比**：列举 2-3 种主流方案，说明各自适用场景
4. **实际经验**：结合自己的项目经历，说明选型和实现
5. **优化和思考**：讨论性能优化、异常处理等

### 关键要点

- **没有银弹**：分布式事务没有完美方案，都是权衡
- **能不用就不用**：通过业务设计尽量避免分布式事务
- **优先最终一致性**：大部分场景不需要强一致
- **做好补偿和监控**：异常情况下的兜底方案很重要