### 小顶堆（Min Heap）
**小顶堆**是一种**完全二叉树**，它满足以下性质：
1. **堆序性**：任意节点的值都**小于或等于**其所有子节点的值。
2. **完全性**：除了最后一层，所有层都被填满，最后一层的节点从左到右依次填充，不留空隙。

简单来说，小顶堆的**根节点存储的是最小值**，适用于求最小值或维护前 K 个最小值等场景。

---

### **小顶堆的示例**
假设有以下一组数字：
```
[4, 8, 6, 15, 10, 20, 7]
```
构建小顶堆后，它的结构如下：
```
        4
       / \
      8   6
     / \  / \
   15 10 20  7
```
但这个并不满足小顶堆的性质（`6` 和 `4` 关系不对），调整后变为：
```
        4
       / \
      7   6
     / \  / \
   15 10 20  8
```
**每个父节点的值都小于等于子节点的值**，符合小顶堆的定义。

---

### **常见操作**
#### **1. 插入元素**
- 把新元素添加到堆的末尾。
- 向上调整（**上浮操作**），确保满足小顶堆性质。

#### **2. 删除堆顶元素**
- 小顶堆的堆顶是最小值，删除后需要用最后一个元素填补堆顶。
- 然后向下调整（**下沉操作**），确保小顶堆性质不变。

#### **3. 建堆**
- 可以通过**插入法**（一个个元素插入空堆，时间复杂度 O(n log n)）。
- 也可以使用**heapify（堆化）**，从倒数第二层开始向下调整，时间复杂度 O(n)。

---

### **Python 实现小顶堆**
Python 的 `heapq` 模块默认是**小顶堆**：
```python
import heapq

heap = []
nums = [4, 8, 6, 15, 10, 20, 7]

# 逐个插入
for num in nums:
    heapq.heappush(heap, num)

print(heap)  # 结果：[4, 8, 6, 15, 10, 20, 7]，但实际是小顶堆结构

# 获取最小元素（堆顶）
print(heapq.heappop(heap))  # 4
print(heap)  # 剩余堆结构会调整
```

**快速构建小顶堆（heapify）**
```python
heapq.heapify(nums)  # 直接堆化
print(nums)  # 结果：[4, 8, 6, 15, 10, 20, 7]
```

---

### **应用场景**
1. **优先队列**（如 Dijkstra 最短路径）
2. **获取最小/最大 K 个元素**（Top K 问题）
3. **动态数据流的中位数维护**
4. **合并多个有序链表**（如 `merge k sorted lists`）

**总结**
- **小顶堆：堆顶是最小值，父节点 ≤ 子节点**
- **常见操作：插入（上浮），删除堆顶（下沉），建堆（heapify）**
- **Python `heapq` 默认实现小顶堆**