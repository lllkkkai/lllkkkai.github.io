---
layout: post
category: Design
---

一个类在整个系统中只有一个实例对象可以被获取和使用。

实现要点：

1. 构造器私有
2. 对外提供静态方法获取实例对象
3. 含有一个该类的静态变量来保存这个唯一的实例

# 为什么要使用单例模式

1. 有效管理和控制资源使用，减少资源消耗和避免不必要的重复创建，提高性能和效率

# 饿汉式

直接创建对象，不存在线程安全问题

优点：写法简单，在类加载的时候完成了实例化，避免了线程同步问题。

缺点：如果从未使用过这个单例，会造成内存浪费。

```java
public class Singleton {
//先把对象创建好
private static final Singleton singleton = new Singleton();

private Singleton() {}
//其他人来拿的时候直接返回已创建好的对象
public static Singleton getInstance() {
  return singleton;
  }
}
```

# 懒汉式

延迟创建对象，存在线程安全问题

因为可能出现外界多人同时访问SingleCase.getInstance()方法，这里可能会出现因为并发问题导致类被实例化多次，所以懒汉模式需要加上锁**synchronized (Singleton.class)**  来控制类只允许被实例化一次。

但加锁的方式会影响性能，因为加锁只需要在第一次初始化的时候使用，之后的调用无需再加锁

```java
/**
 * 单例模式案例
 */
public class Singleton {

 private static Singleton singleton = null;

 private Singleton() {
    }
  //获取对象的时候再进行实例化
 public static Singleton getInstance() {
     synchronized (Singleton.class) {

 if (singleton == null) {
 singleton = new Singleton();
            }

   }
 return singleton;
    }
```

## 双重校验锁（Double Checked Locking）

针对上文问题的优化：先判断对象是否初始化，再决定要不要加锁

```java
public class Singleton {
    private static Singleton singleton ;

    private Singleton() {
    }

    public Singleton getInstance() {
        if (null == singleton ) {
            synchronized (Singleton.class) {
                if (null == singleton ) {
                    singleton = new Singleton();   // error
                }
            }
        }
        return singleton ;
    }
}

```

运行顺序：

1. 检查变量是否被初始化(不去获得锁)，如果已被初始化则立即返回。
2. 获取锁。
3. 再次检查变量是否已经被初始化，如果还没被初始化就初始化一个对象。

执行双重检查是因为，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。

这样，除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题。

### 隐患

上述写法看似解决了问题，但是有个很大的隐患。实例化对象的那行代码（singleton= new Singleton()），实际上可以分解成以下三个步骤：

1. 在堆中给singleton分配内存空间
2. 在堆中实例化对象singleton的各个参数
3. 将singleton对象指向刚分配的堆内存空间

但是由于JVM具有指令重排的特性，执行顺序有可能变成 1-3-2。指令重排在单线程下不会出现问题，但是在多线程下会导致一个线程获得一个未初始化的实例。

例如：线程T1执行了1和3，此时T2调用 getInstance() 后发现 singleton 不为空，因此返回 singleton， 但是此时的singleton还没有被初始化。

使用 volatile 会禁止JVM指令重排，从而保证在多线程下也能正常执行。

### 正确的DCL

```java
public class Singleton {
    private volatile static Singleton singleton; //声明为volatile

    private Singleton() {
    }

    public Singleton getInstance() {
        if (null == singleton) {
            synchronized (Singleton.class) {
                if (null == singleton) {
                    singleton= new Singleton();
                }
            }
        }
        return singleton;
    }
}

```

为了解决上述问题，需要在`singleton`前加入关键字`volatile`。使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。

## 静态内部类

静态内部类不会随着外部类的加载而加载，只有当调用 `getInstance()` 访问内部类属性时，才会触发内部类的加载和初始化。

```java
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**核心原理：**

1.  **延迟加载**：外部类加载时，静态内部类不会被加载。只有调用 `getInstance()` 时，JVM 才会加载 `SingletonHolder`。
2.  **线程安全**：JVM 在加载类时会保证安全（利用 `<clinit>()` 方法的加锁机制），确保 `INSTANCE` 只被实例化一次。

这种方式既实现了懒加载，又利用 JVM 机制保证了线程安全，代码还非常简洁。