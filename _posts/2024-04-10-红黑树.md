---
layout: post
category: ds
---

# AVL树 平衡二叉树

AVL树的查找、插入和删除在平均和最坏情况下都是**O(logn)**

# 什么是红黑树

红黑树是一种近似平衡的二叉查找树，其主要的优点就是“平衡“，即左右子树高度几乎一致，以此来防止树退化为链表，通过这种方式来保障查找的时间复杂度为 log(n)

# 为什么使用？

存储有序的数据，**它增删改查的时间复杂度都是O(logn)** 。

## 红黑树的特征

1. 节点颜色：每个节点要么是红色，要么是黑色。
2. 根节点：根节点是黑色。
3. 叶子节点：所有叶子节点（NIL 节点，空节点）是黑色。
4. 红色节点的子节点：如果一个节点是红色的，则它的两个子节点都是黑色的。
5. 路径上的黑色节点数量：对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。

红黑树的左旋和右旋是用于保持红黑树性质的两种基本操作，主要用于在插入或删除节点后对树的结构进行调整，以下是关于左旋和右旋的详细介绍：

### 左旋
- **定义**：左旋是对红黑树中某个节点进行的一种操作，假设当前节点为`x`，左旋操作会将`x`的右子节点`y`提升为新的根节点，同时`x`变为`y`的左子节点，`y`原来的左子节点则变为`x`的右子节点。
- **操作步骤**
    1. 首先，将`y`的左子节点赋给`x`的右子节点，即`x.right = y.left`，如果`y.left`不为空，则将`y.left`的父节点设置为`x`。
    2. 然后，将`x`的父节点赋给`y`的父节点，如果`x`是根节点，则更新根节点为`y`；否则，根据`x`是其父节点的左子节点还是右子节点，将`y`设置为相应的子节点。
    3. 最后，将`x`设置为`y`的左子节点，即`y.left = x`，并将`x`的父节点设置为`y`。
- **作用**：通过将节点向右下方移动，使得以`x`为根的子树在高度上可能会降低，或者调整节点的位置以满足红黑树在插入或删除操作后的平衡性质等要求，让树的结构更符合红黑树的规则，保持树的平衡和性能。

### 右旋
- **定义**：右旋与左旋相反，假设当前节点为`y`，右旋操作会将`y`的左子节点`x`提升为新的根节点，`y`变为`x`的右子节点，`x`原来的右子节点则变为`y`的左子节点。
- **操作步骤**
    1. 首先，将`x`的右子节点赋给`y`的左子节点，即`y.left = x.right`，如果`x.right`不为空，则将`x.right`的父节点设置为`y`。
    2. 然后，将`y`的父节点赋给`x`的父节点，如果`y`是根节点，则更新根节点为`x`；否则，根据`y`是其父节点的左子节点还是右子节点，将`x`设置为相应的子节点。
    3. 最后，将`y`设置为`x`的右子节点，即`x.right = y`，并将`y`的父节点设置为`x`。
- **作用**：通过将节点向左下方移动，使得以`y`为根的子树在高度上可能会降低，或者调整节点的位置以满足红黑树在插入或删除操作后的平衡性质等要求，保持树的平衡和性能。

下面以简单示例说明左旋右旋操作：
```
        3           5
       / \         / \
      2   5   ->  3   6
         / \     / \
        4   6   2   4
```
上述示例中，对节点3进行左旋操作，节点5成为新的根节点，节点3变为节点5的左子节点，节点5原来的左子节点4变为节点3的右子节点。右旋操作与之相反，例如对节点5进行右旋操作，则节点3会成为新的根节点，节点5变为节点3的右子节点等。



## 红黑树有什么缺点 如何优化

优点：

1. 插入和删除操作的效率高于AVL树。红黑树通过非严格的平衡来换取增删节点时旋转次数的降低，任何不平衡都会在三次旋转之内解决，而AVL树是严格平衡树，因此在增加或删除节点时，旋转的次数比红黑树要多。
2. 对于删除节点导致失衡后的复衡操作，红黑树能够提供一个相对较便宜的解决方案，降低开销。相比之下，AVL树需要维护从被删除节点到根节点路径上所有节点的平衡，旋转的量级为O(logN)，而红黑树最多只需要旋转3次实现复衡，只需O(1)的开销。

缺点：

1. 查找操作的效率略低于AVL树。由于红黑树不要求完全平衡，查询性能可能略逊于AVL树。最多只有一层的不平衡，也就是说，红黑树的查询性能最多多一次比较，相对于相同内容的AVL树。
2. 红黑树的平衡性相对于AVL树来说较差。红黑树只要求部分达到平衡，不像AVL树那样要求节点的平衡因子的绝对值小于等于1。这也是为了在插入和删除节点时降低旋转的次数和开销，而AVL树是严格平衡的。

综合来说，红黑树在功能、性能和空间开销之间进行了折中。它具有较高的统计性能，适用于需要稳定表现的场景，尤其在插入和删除操作频繁的情况下，红黑树的效率更高。相比之下，AVL树更加平衡，读取时的效率更高，但在维护和空间开销方面稍慢一些。